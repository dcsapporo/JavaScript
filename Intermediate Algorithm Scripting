//Now that you know the basics of algorithmic thinking, along with OOP and Functional Programming, 
//    test your skills with the Intermediate Algorithm Scripting challenges.

//Sum All Numbers in a Range
//We'll pass you an array of two numbers. 
//Return the sum of those two numbers plus the sum of all the numbers between them. 
//The lowest number will not always come first.

//For example, 'sumAll([4,1])' should return '10' because sum of all the numbers between 1 and 4 (both inclusive) is '10'.


//UNCHANGED CODE:

//    function sumAll(arr) {
//      return 1;
//    }

//    sumAll([1, 4]);

//CHANGED CODE:
///////////////////1st Experiment
function sumAll(arr) {
  console.log(arr);
  let newArr = arr.slice().sort();
  console.log(newArr);
  let difference = [];
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] > newArr[i]) {
      difference.push(arr[i] - newArr[i]);
      console.log(difference);
    } else if(arr[i] = newArr[i]) {
      let invertArr = [];
      invertArr.push(newArr.pop());
      console.log(invertArr);
      difference.push(invertArr[i] - arr[i]);
      console.log(difference);
    }
  } console.log(difference);

  return 1;
}

sumAll([1, 4]);
////////////////////////////////////////////
\\\\\\\\\\\\\\\\\\\\2nd Experiment:
function sumAll(arr) {
  console.log(arr);
  const arrClone = [...arr];
  
  const lastItem = arrClone.pop();
 
  const invertArr = [];
  arr.forEach(elementValue => {
    
    if (elementValue > lastItem) {
      invertArr.push(lastItem);
      invertArr.push(arrClone.shift());
      return invertArr;
    }
  });
  console.log(invertArr);
  let difference = [];
  arr.filter(elementValue => {
    let largerValue = [];
    let lowerValue = [];
    
    if (elementValue < lastItem) {
      //console.log(elementValue);
      lowerValue.push(elementValue);
      difference = lastItem - lowerValue;
      return difference;
    } else if (elementValue > lastItem) {
      //console.log(elementValue);
      largerValue.push(elementValue);
      difference = largerValue - lastItem;
      return difference;
    }
  }, 0);
  console.log(difference)
  const newArr = [];
  
  return 1;
}

sumAll([1, 4]);
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
////////////////////3rd Experiment
function sumAll(arr) {
  console.log(arr);
  const arrClone = [...arr];

  const firstItem = arrClone.slice(0,1);
  console.log(firstItem);
  const lastItem = arrClone.slice(1);
  //console.log(lastItem);
  const invertArr = [];
  arr.forEach(elementValue => {
    
    if (elementValue > lastItem) {
      invertArr.push(lastItem);
      invertArr.push(arrClone.shift());
      return invertArr;
    }
  });
  console.log(invertArr);

  let difference = [];
  arr.filter(elementValue => {
    let largerValue = [];
    let lowerValue = [];
    
    if (elementValue < lastItem) {
      //console.log(elementValue);
      lowerValue.push(elementValue);
      difference = lastItem - lowerValue;
      return difference;
    } else if (elementValue > lastItem) {
      //console.log(elementValue);
      largerValue.push(elementValue);
      difference = largerValue - lastItem;
      return difference;
    }
  }, 0);
  console.log(difference)
  let allNums = [];
  arr.map(elementValue => {
    if (difference > firstItem) {
      let firstItemArr = firstItem.slice();
      //console.log(lastItem.valueOf());
      for (let i = firstItemArr.valueOf(); i < lastItem.valueOf(); i++) {
        //console.log(i);
        allNums.push(i);
      };
    } else if (difference <= firstItem) {
        let firstItemArr = firstItem.slice();
        let lastItemArr = lastItem.slice();
        //console.log(lastItem.valueOf());
        for (let i = lastItemArr.valueOf(); i < firstItemArr.valueOf(); i++) {
        //console.log(i);
        allNums.push(i);
      };
    }
  });
  console.log(allNums)
  const newArr = [];
  
  return 1;
}

sumAll([1, 4]);
////////////////////////////////////////////
\\\\\\\\\\\\\\\\\4th Variation:
function sumAll(arr) {
  console.log(arr);
//Making a copy of the array to avoid mutations
  const arrClone = [...arr];
//Checking the order of elements and sorting them in a new array
  const arrangedArrClone = arrClone.sort(function(a,b){return a - b});
  console.log(arrangedArrClone);
//Extracting the first and last elements 
  const firstItem = arrangedArrClone.slice(0,1);
  console.log(firstItem);
  const lastItem = arrangedArrClone.slice(1);
  console.log(lastItem);
//Finding the difference between the two elements
  let difference = [];
  arrangedArrClone.filter(elementValue => {
    let largerValue = [];
    let lowerValue = [];
    if (elementValue < lastItem) {
      //console.log(elementValue);
      lowerValue.push(elementValue);
      difference = lastItem - lowerValue;
      return difference;
    } else if (elementValue > lastItem) {
      //console.log(elementValue);//This check is leftover and should have no effect on the code should it be removed, 
      //since the arrangedArrClone is present
      largerValue.push(elementValue);
      difference = largerValue - lastItem;
      return difference;
    }
  }, 0);
  console.log(difference)
//Finding the missing values between the given elements
  let missingNumsArr = [];
  
  console.log(missingNumsArr);
  const newArr = [];  
  return 1;
}

sumAll([10, 5]);
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
/////////////////////////5th Variation
function sumAll(arr) {
  console.log(arr);
//Making a copy of the array to avoid mutations
  const arrClone = [...arr];
//Checking the order of elements and sorting them in a new array
  const arrangedArrClone = arrClone.sort(function(a,b){return a - b});
  console.log(arrangedArrClone);
//Extracting the first and last elements 
  const firstItem = arrangedArrClone.slice(0,1);
  console.log(firstItem);
  const lastItem = arrangedArrClone.slice(1);
  console.log(lastItem);
//Setting variable to store missing data
  let missingNumsArr = [];
//Finding the difference between the two elements
  let difference = [];
  arrangedArrClone.filter(elementValue => {
    let largerValue = [];
    let lowerValue = [];
    if (elementValue < lastItem) {
      //console.log(elementValue);
      lowerValue.push(elementValue);
      difference = lastItem - lowerValue;
      return difference;
    } else if (elementValue > lastItem) {
      //console.log(elementValue);//This check is leftover and should have no effect on the code should it be removed, 
      //since the arrangedArrClone is present
      largerValue.push(elementValue);
      difference = largerValue - lastItem;
      return difference;
    }
  }, 0);
  console.log(difference);
//Adding missing data value of last item to be added 
  if (difference != firstItem){
  missingNumsArr.push(difference);
  };
  //console.log(missingNumsArr);
//Finding the missing values between the given elements
  
  arrangedArrClone.map(elementValue => {
    if (elementValue < difference) {
      return missingNumsArr.unshift(difference - elementValue);  
    } if (elementValue === difference) {
      console.log(missingNumsArr.push(difference + 1));   
    }; 
  });
  
  console.log(missingNumsArr);
  const newArr = [];  
  return 1;
}

sumAll([1, 4]);
///////////////////////////////////////
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\6th Variation:
function sumAll(arr) {
  console.log(arr);
//Making a copy of the array to avoid mutations
  const arrClone = [...arr];
//Checking the order of elements and sorting them in a new array
  const arrangedArrClone = arrClone.sort(function(a,b){return a - b});
  console.log(arrangedArrClone);
//Extracting the first and last elements 
  const firstItem = arrangedArrClone.slice(0,1);
  console.log(firstItem);
  const lastItem = arrangedArrClone.slice(1);
  console.log(lastItem);
//Setting variable to store missing data
  let missingNumsArr = [];
//Finding the difference between the two elements
  let difference = [];
  arrangedArrClone.filter(elementValue => {
    let largerValue = [];
    let lowerValue = [];
    if (elementValue < lastItem) {
      //console.log(elementValue);
      lowerValue.push(elementValue);
      difference = lastItem - lowerValue;
      return difference;
    } else if (elementValue > lastItem) {
      //console.log(elementValue);//This check is leftover and should have no effect on the code should it be removed, since the arrangedArrClone is present
      largerValue.push(elementValue);
      difference = largerValue - lastItem;
      return difference;
    }
  }, 0);
  console.log(difference);
//Adding missing data value of last item to be added 
  if (difference != firstItem){
  missingNumsArr.push(difference);
  };
  //console.log(missingNumsArr);
//Finding the missing values between the given elements
  
  arrangedArrClone.map(elementValue => {
    if (elementValue < difference) {
      return missingNumsArr.unshift(difference - elementValue);  
    } if (elementValue === difference) {
      console.log(missingNumsArr.push(difference + 1));   
    }; 
  });
  
  console.log(missingNumsArr);
  let newArr = [];
  if (firstItem === 1) {
    newArr = lastItem * (lastItem + firstItem) / 2 ;
    return newArr;  
  };
  if (firstItem > 1) {
    newArr = (lastItem * (lastItem + 1) / 2) - (firstItem * (firstItem - 1) / 2)
  };
  console.log(newArr);
   
  return 1;
}

sumAll([10, 5]);
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
//////////////////////////////////////////////////THE SOLUTION CODE:
function sumAll(arr) {
  console.log(arr);
//Making a copy of the array to avoid mutations
  const arrClone = [...arr];
//Checking the order of elements and sorting them in a new array
  const arrangedArrClone = arrClone.sort(function(a,b){return a - b});
  console.log(arrangedArrClone[1]);
//
  const newArr = [];
  let sumOfAll = arrangedArrClone.filter(elementValue => {
      //console.log(elementValue)
      if (elementValue === 1) {
        sumOfAll = (arrangedArrClone[1] * (elementValue+ arrangedArrClone[1])) / 2;
        console.log(sumOfAll);
        newArr.push(sumOfAll);
        return newArr;
      } else if (elementValue > 1) {
        sumOfAll = ((arrangedArrClone[1] * (1 + arrangedArrClone[1])) / 2) - ((arrangedArrClone[0] * (arrangedArrClone[0] - 1)) / 2);
        console.log(sumOfAll);
        newArr.push(sumOfAll);
        return newArr;
      }    
  });
  let result = newArr.pop()
  console.log(newArr.valueOf());
  return result;

};

sumAll([1, 4]);
/////////////////////////////////////////////////////////


//OUTPUT:
////////////////1st output
[ 1, 4 ]
[ 1, 4 ]
[ 4 ]
[ 3 ]
[ 3 ]
/////////[5,10] input
[ 5, 10 ]
[ 10, 5 ]
[ 5 ]
[ -5 ]
[ -5 ]
/////////////////
\\\\\\\\\\2nd output
[ 1, 4 ]
[]
3
\\\\\\\\\\\\\[10, 5] input
[ 10, 5 ]
[ 5, 10 ]
5
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
///////////////3rd output
[ 1, 4 ]
[ 1 ]
[]
3
[ [ 1 ], 2, 3, [ 1 ], 2, 3 ]
///////////////////////////////
\\\\\\\\\\\\\\\\\4th output
[ 10, 5 ]
[ 5, 10 ]
[ 5 ]
[ 10 ]
5
[]
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
/////////////////5th output
[ 1, 4 ]
[ 1, 4 ]
[ 1 ]
[ 4 ]
3
[ 2, 3 ]
////////////////input [10, 5]
[ 10, 5 ]
[ 5, 10 ]
[ 5 ]
[ 10 ]
5
1
[ 6 ]
///////////////////////////////////
\\\\\\\\\\\\\\\\\\\\6th output:
[ 10, 5 ]
[ 5, 10 ]
[ 5 ]
[ 10 ]
5
1
[ 6 ]
495
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
////////////////////////THE SOLUTION OUTPPUT:
[10]
[45]
////////////////////////////////////////////////////////

//Diff Two Arrays
//Compare two arrays and return a new array with any items only found in one of the two given arrays, 
//    but not both. 
//In other words, return the "symmetric difference" of the two arrays.

//Note: You can return the array with its elements in any order.


//UNCHANGED CODE:

//    function diffArray(arr1, arr2) {
//      const newArr = [];
//      return newArr;
//    }

//    diffArray([1, 2, 3, 5], [1, 2, 3, 4, 5]);

//CHANGED CODE:
\\\\\\\\\\\\\\\\\\\\\\\\1st Attempt
function diffArray(arr1, arr2) {
  const newArr = [];
  console.log(arr1);
  console.log(arr2);
//Cloning of arrays
  let cloneArr1 = [...arr1];
  console.log(cloneArr1);
  let cloneArr2 = [...arr2];
  console.log(cloneArr2);
//Creating a length array for both
  let lengthArr = [];
  const arr1Length = arr1.length;
  console.log(arr1Length);
  lengthArr.push(arr1Length);
  const arr2Length = arr2.length;
  console.log(arr2Length);
  lengthArr.push(arr2Length);
  console.log(lengthArr);
//Creating the filter to find which is the longer array
  let longestArr = [];
    if (arr1Length > arr2Length || arr1Length === arr2Length) {
      longestArr = cloneArr1.slice();
      console.log(longestArr)
    } else if (arr1Length < arr2Length) {
      longestArr = cloneArr2.slice();
      console.log(longestArr)
    };
  //console.log(longestArr)

  return newArr;
}

diffArray([1, 2, 3, 5], [1, 2, 3, 4, 5]);
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
///////////////////////Attempt 2
function diffArray(arr1, arr2) {
  const newArr = [];
  console.log(arr1);
  console.log(arr2);
//Cloning of arrays
  let cloneArr1 = [...arr1];
  console.log(cloneArr1);
  let cloneArr2 = [...arr2];
  console.log(cloneArr2);
//Creating a length array for both
  let lengthArr = [];
  const arr1Length = arr1.length;
  console.log(arr1Length);
  lengthArr.push(arr1Length);
  const arr2Length = arr2.length;
  console.log(arr2Length);
  lengthArr.push(arr2Length);
  console.log(lengthArr);
//Creating the filter to find which is the longer array
  let longestArr = [];
  let shortestArr = [];
  let equalLengthArr1 = [];
  let equalLengthArr2 = [];
    if (arr1Length > arr2Length) {
      longestArr = cloneArr1.slice();
      console.log(longestArr);
      shortestArr = cloneArr2.slice();
      console.log(shortestArr);
    } else if (arr1Length < arr2Length) {
      longestArr = cloneArr2.slice();
      console.log(longestArr);
      shortestArr = cloneArr1.slice();
      console.log(shortestArr);
    } else if (arr1Length === arr2Length) {
      equalLengthArr1 = cloneArr1.slice();
      console.log(equalLengthArr1);
      equalLengthArr2 = cloneArr2.slice();
      console.log(equalLengthArr2);
    };
  //console.log(longestArr);

  return newArr;
}

diffArray([1, 2, 3, 5], [1, 2, 3, 4, 5]);
//////////////////////////////////////////////////////
\\\\\\\\\\\\\\\\\\\\\\\\\\\Attempt 3
function diffArray(arr1, arr2) {
  const newArr = [];
  //console.log(arr1);
  //console.log(arr2);
//Cloning of arrays
  let cloneArr1 = [...arr1];
  //console.log(cloneArr1);
  let cloneArr2 = [...arr2];
  //console.log(cloneArr2);
//Creating a length array for both
  let lengthArr = [];
  const arr1Length = arr1.length;
  //console.log(arr1Length);
  lengthArr.push(arr1Length);
  const arr2Length = arr2.length;
  //console.log(arr2Length);
  lengthArr.push(arr2Length);
  //console.log(lengthArr);
//Creating the filter to find which is the longer array
  let longestArr = [];
  let shortestArr = [];
  let equalLengthArr1 = [];
  let equalLengthArr2 = [];
    if (arr1Length > arr2Length) {
      longestArr = cloneArr1.slice();
      //console.log(longestArr);
      shortestArr = cloneArr2.slice();
      //console.log(shortestArr);
    } else if (arr1Length < arr2Length) {
      longestArr = cloneArr2.slice();
      //console.log(longestArr);
      shortestArr = cloneArr1.slice();
      //console.log(shortestArr);
    } else if (arr1Length === arr2Length) {
      equalLengthArr1 = cloneArr1.slice();
      //console.log(equalLengthArr1);
      equalLengthArr2 = cloneArr2.slice();
      //console.log(equalLengthArr2);
    };
  console.log(longestArr);
//Setting symmetrical difference arrays
  let preSymDifArr1 = [];
  let preSymDifArr2 = [];
  if (cloneArr1 === longestArr) {
    preSymDifArr1 = longestArr.slice();
    console.log(preSymDifArr1);
    preSymDifArr2 = shortestArr.slice();
    console.log(preSymDifArr2);
  } else if (cloneArr2 === longestArr) {
    preSymDifArr1 = longestArr.slice();
    console.log(preSymDifArr1);
    preSymDifArr2 = shortestArr.slice();
    console.log(preSymDifArr2);
  } else if (arr1Length === arr2Length) {
    preSymDifArr1 = longestArr.slice();
    console.log(preSymDifArr1);
    preSymDifArr2 = shortestArr.slice();
    console.log(preSymDifArr2);
  };
//Filter out difference
  let symDif = longestArr.filter(elementValue => {
    let shortDif = shortestArr.filter(shortItem => {
      if (elementValue === shortItem) {
        console.log(shortItem);
        console.log(elementValue);
        newArr.push(elementValue);
        
      };  
      return shortDif;
    }); 
    return symDif;
  });console.log(newArr);

  return newArr;
}

diffArray([1, 2, 3, 5], [1, 2, 3, 4, 5]);
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
///////////////////////////////1st SOLUTION:
function diffArray(arr1, arr2) {
  const newArr = [];
  //console.log(arr1);
  //console.log(arr2);
//Cloning of arrays
  let cloneArr1 = [...arr1];
  //console.log(cloneArr1);
  let cloneArr2 = [...arr2];
  //console.log(cloneArr2);
//Creating a length array for both
  let lengthArr = [];
  const arr1Length = arr1.length;
  //console.log(arr1Length);
  lengthArr.push(arr1Length);
  const arr2Length = arr2.length;
  //console.log(arr2Length);
  lengthArr.push(arr2Length);
  //console.log(lengthArr);
//Creating the filter to find which is the longer array
  let longestArr = [];
  let shortestArr = [];
  let equalLengthArr1 = [];
  let equalLengthArr2 = [];
    if (arr1Length > arr2Length) {
      longestArr = cloneArr1.slice();
      //console.log(longestArr);
      shortestArr = cloneArr2.slice();
      //console.log(shortestArr);
    } else if (arr1Length < arr2Length) {
      longestArr = cloneArr2.slice();
      //console.log(longestArr);
      shortestArr = cloneArr1.slice();
      //console.log(shortestArr);
    } else if (arr1Length === arr2Length) {
      equalLengthArr1 = cloneArr1.slice();
      //console.log(equalLengthArr1);
      equalLengthArr2 = cloneArr2.slice();
      //console.log(equalLengthArr2);
    };
  console.log(longestArr);
//Setting symmetrical difference arrays
  let preSymDifArr1 = [];
  let preSymDifArr2 = [];
  if (cloneArr1 === longestArr) {
    preSymDifArr1 = longestArr.slice();
    console.log(preSymDifArr1);
    preSymDifArr2 = shortestArr.slice();
    console.log(preSymDifArr2);
  } else if (cloneArr2 === longestArr) {
    preSymDifArr1 = longestArr.slice();
    console.log(preSymDifArr1);
    preSymDifArr2 = shortestArr.slice();
    console.log(preSymDifArr2);
  } else if (arr1Length === arr2Length) {
    preSymDifArr1 = longestArr.slice();
    console.log(preSymDifArr1);
    preSymDifArr2 = shortestArr.slice();
    console.log(preSymDifArr2);
  };
//Filter out difference
  let symDif = longestArr.filter(elementValue => {
    
      if (shortestArr.includes(elementValue) === false ) {
        console.log(shortestArr);
        console.log(elementValue);
        newArr.push(elementValue);
        symDif = newArr;
        return symDif;
    }; 
    
  });console.log(symDif)
  console.log(newArr);

  return newArr;
}

diffArray([1, 2, 3, 5], [1, 2, 3, 4, 5]);
///////////////////////////////////////////////////////////////
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\2nd SOLUTION;
function diffArray(arr1, arr2) {
  const newArr = [];
  //console.log(arr1);
  //console.log(arr2);
//Cloning of arrays
  let cloneArr1 = [...arr1];
  //console.log(cloneArr1);
  let cloneArr2 = [...arr2];
  //console.log(cloneArr2);
//Creating a length array for both
  let lengthArr = [];
  const arr1Length = arr1.length;
  //console.log(arr1Length);
  lengthArr.push(arr1Length);
  const arr2Length = arr2.length;
  //console.log(arr2Length);
  lengthArr.push(arr2Length);
  //console.log(lengthArr);
//Creating the filter to find which is the longer array
  let longestArr = [];
  let shortestArr = [];
  let equalLengthArrA = [];
  let equalLengthArrB = [];
    if (arr1Length > arr2Length) {
      longestArr = cloneArr1.slice();
      //console.log(longestArr);
      shortestArr = cloneArr2.slice();
      //console.log(shortestArr);
    } else if (arr1Length < arr2Length) {
      longestArr = cloneArr2.slice();
      //console.log(longestArr);
      shortestArr = cloneArr1.slice();
      //console.log(shortestArr);
    } else if (arr1Length === arr2Length) {
      equalLengthArrA = cloneArr1.slice();
      //console.log(equalLengthArr1);
      equalLengthArrB = cloneArr2.slice();
      //console.log(equalLengthArr2);
    };
  console.log(longestArr);
  console.log(equalLengthArrA);
  console.log(equalLengthArrB);
  let includeResult = [];
  console.log(includeResult = equalLengthArrA.includes(equalLengthArrB))
//Setting symmetrical difference arrays
  let preSymDifArr1 = [];
  let preSymDifArr2 = [];
  if (cloneArr1 === longestArr) {
    preSymDifArr1 = longestArr.slice();
    console.log(preSymDifArr1);
    preSymDifArr2 = shortestArr.slice();
    console.log(preSymDifArr2);
  } else if (cloneArr2 === longestArr) {
    preSymDifArr1 = longestArr.slice();
    console.log(preSymDifArr1);
    preSymDifArr2 = shortestArr.slice();
    console.log(preSymDifArr2);
  } else if (arr1Length === arr2Length) {
    preSymDifArr1 = longestArr.slice();
    console.log(preSymDifArr1);
    preSymDifArr2 = shortestArr.slice();
    console.log(preSymDifArr2);
  };
//Filter out difference
  let symDifLong = longestArr.filter(elementValue => {
    
      if (shortestArr.includes(elementValue) === false ) {
        //console.log(shortestArr);
        //console.log(elementValue);
        newArr.push(elementValue);
        symDifLong = newArr;
        return symDifLong;
    };    
  });
  let symDifShort = shortestArr.filter(elementValue => {
      if (longestArr.includes(elementValue) === false && newArr.length !== 1 || newArr === []) {
        console.log(longestArr);
        console.log(elementValue);
        newArr.push(elementValue);
        symDifShort = newArr;
        return symDifShort;
      };
  });
  let symDifEqualA = equalLengthArrA.filter(elementValue => {
    if (includeResult === false) {
      console.log(equalLengthArrB);
      console.log(elementValue);
      newArr.push(elementValue);
      symDifEqualA = newArr;
      return symDifEqualA;
    };
  });
  console.log(symDifLong);
  console.log(symDifShort);
  console.log(newArr);

  return newArr;
}

diffArray([1, "calf", 3, "piglet"], [1, "calf", 3, 4]);
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
///////////////////////////////////3rd SOLUTION:
function diffArray(arr1, arr2) {
  const newArr = [];
  //console.log(arr1);
  //console.log(arr2);
//Cloning of arrays
  let cloneArr1 = [...arr1];
  //console.log(cloneArr1);
  let cloneArr2 = [...arr2];
  //console.log(cloneArr2);
//Creating a length array for both
  let lengthArr = [];
  const arr1Length = arr1.length;
  //console.log(arr1Length);
  lengthArr.push(arr1Length);
  const arr2Length = arr2.length;
  //console.log(arr2Length);
  lengthArr.push(arr2Length);
  //console.log(lengthArr);
//Creating the filter to find which is the longer array
  let longestArr = [];
  let shortestArr = [];
  let equalLengthArrA = [];
  let equalLengthArrB = [];
    if (arr1Length > arr2Length) {
      longestArr = cloneArr1.slice();
      //console.log(longestArr);
      shortestArr = cloneArr2.slice();
      //console.log(shortestArr);
    } else if (arr1Length < arr2Length) {
      longestArr = cloneArr2.slice();
      //console.log(longestArr);
      shortestArr = cloneArr1.slice();
      //console.log(shortestArr);
    } else if (arr1Length === arr2Length) {
      equalLengthArrA = cloneArr1.slice();
      //console.log(equalLengthArr1);
      equalLengthArrB = cloneArr2.slice();
      //console.log(equalLengthArr2);
    };
  //console.log(longestArr);
  //console.log(equalLengthArrA);
  //console.log(equalLengthArrB);
  let includeResultA = [];
  let includeResultB = [];
  console.log(includeResultA = equalLengthArrA.includes(equalLengthArrB));
  console.log(includeResultB = equalLengthArrB.includes(includeResultA));
//Setting symmetrical difference arrays
  let preSymDifArrA = [];
  let preSymDifArrB = [];
  if (cloneArr1 === longestArr) {
    preSymDifArrA = longestArr.slice();
    //console.log(preSymDifArrA);
    preSymDifArrB = shortestArr.slice();
    //console.log(preSymDifArrB);
  } else if (cloneArr2 === longestArr) {
    preSymDifArrA = longestArr.slice();
    //console.log(preSymDifArrA);
    preSymDifArrB = shortestArr.slice();
    //console.log(preSymDifArrB);
  } else if (arr1Length === arr2Length) {
    preSymDifArrA = [...equalLengthArrA];
    console.log(preSymDifArrA);
    preSymDifArrB = equalLengthArrB.slice();
    console.log(preSymDifArrB);
  };
//Filter out difference
  let symDifLong = longestArr.filter(elementValue => {
    
      if (shortestArr.includes(elementValue) === false ) {
        //console.log(shortestArr);
        //console.log(elementValue);
        newArr.push(elementValue);
        symDifLong = newArr;
        return symDifLong;
    };    
  });
  let symDifShort = shortestArr.filter(elementValue => {
      if (longestArr.includes(elementValue) === false && newArr.length !== 1 || newArr === []) {
        //console.log(longestArr);
        //console.log(elementValue);
        newArr.push(elementValue);
        symDifShort = newArr;
        return symDifShort;
      };
  });
  let symDifEqualA = equalLengthArrA.filter(elementValue => {
    if (preSymDifArrB.includes(elementValue) === false) {
      console.log(equalLengthArrB);
      console.log(elementValue);
      newArr.push(elementValue);
      symDifEqualA = newArr;
      return symDifEqualA;
    };
  });
  let symDifEqualB = equalLengthArrB.filter(elementValue => {
    if (preSymDifArrA.includes(elementValue) === false) {
      console.log(equalLengthArrB);
      console.log(elementValue);
      newArr.push(elementValue);
      symDifEqualB = newArr;
      return symDifEqualB;
    };
  });
  //console.log(symDifLong);
  //console.log(symDifShort);
  console.log(newArr);

  return newArr;
}

diffArray([1, "calf", 3, "piglet"], [1, "calf", 3, 4]);
/////////////////////////////////////////////////////////////

//OUTPUT:
\\\\\\\\\\\\\\\\\\\\\\\\\1st output:
[ 1, 2, 3, 5 ]
[ 1, 2, 3, 4, 5 ]
[ 1, 2, 3, 5 ]
[ 1, 2, 3, 4, 5 ]
4
5
[ 4, 5 ]
[ 1, 2, 3, 4, 5 ]
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
/////////////////////////////2nd output:
[ 1, 2, 3, 5 ]
[ 1, 2, 3, 4, 5 ]
[ 1, 2, 3, 5 ]
[ 1, 2, 3, 4, 5 ]
4
5
[ 4, 5 ]
[ 1, 2, 3, 4, 5 ]
[ 1, 2, 3, 5 ]
///////////////////////////////////////////////////
\\\\\\\\\\\\\\\\\\\\\\\\3rd output:
[ 1, 2, 3, 4, 5 ]
1
1
2
2
3
3
5
5
[ 1, 2, 3, 5 ]
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
///////////////////////////////1st SOLUTION OUTPUT:
[ 1, 2, 3, 4, 5 ]
[ 1, 2, 3, 5 ]
4
[ 4 ]
[ 4 ]
///////////////////////////////////////////////////////
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\2nd SOLUTION OUTPUT:
[]
[ 1, 'calf', 3, 'piglet' ]
[ 1, 'calf', 3, 4 ]
false
[]
[]
[ 1, 'calf', 3, 4 ]
1
[ 1, 'calf', 3, 4 ]
calf
[ 1, 'calf', 3, 4 ]
3
[ 1, 'calf', 3, 4 ]
piglet
[]
[]
[ 1, 'calf', 3, 'piglet' ]
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
/////////////////////////////3rd SOLUTION OUTPUT:
false
false
[ 1, 'calf', 3, 'piglet' ]
[ 1, 'calf', 3, 4 ]
[ 1, 'calf', 3, 4 ]
piglet
[ 1, 'calf', 3, 4 ]
4
[ 'piglet', 4 ]
//////////////////////////////////////////////////////////

//Seek and Destroy
//You will be provided with an initial array (the first argument in the 'destroyer' function), followed by one or more arguments. 
//Remove all elements from the initial array that are of the same value as these arguments.

//Note: You have to use the 'arguments' object.


//    //UNCHANGED CODE:

//    function destroyer(arr) {
//      return arr;
//    }

//    destroyer([1, 2, 3, 1, 2, 3], 2, 3);

//CHANGED CODE:
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\1st Experimental code:
function destroyer(arr) {
  let remainingElements = [];
  console.log(Object.values(arguments));
  let targets = Object.values(arguments).splice(1);
  console.log(targets);
  let searchArr = arr.slice();
  console.log(searchArr);

  for (let i = 0; i < searchArr.length; i ++){
    console.log(searchArr[i]);
    if (searchArr[i] === targets[i]){
      
    }
  }
  let removeElements = searchArr.filter(elementValue => {
   
  });
  return arr;
}

destroyer([1, 2, 3, 1, 2, 3], 2, 3);
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
////////////////////////////SOLUTION CODE:
function destroyer(arr) {
  let remainingElements = [];
  console.log(Object.values(arguments));
  let targets = Object.values(arguments).splice(1);
  console.log(targets);
  let searchArr = arr.slice();
  console.log(searchArr);

  for (let i = 0; i < searchArr.length; i ++){
    let positionToEliminate = searchArr[i];
    if (targets.indexOf(positionToEliminate) === -1){
        remainingElements.push(positionToEliminate);
    };
  };
  /*let removeElements = searchArr.filter(elementValue => {
   
  });*/
  console.log(remainingElements);
  return remainingElements;
}

destroyer([1, 2, 3, 1, 2, 3], 2, 3);
//////////////////////////////////////////////////
\\\\\\\\\\\\\\\\\\\\Variation code: replace for loop
searchArr.forEach(positionToEliminate => {
   if (targets.indexOf(positionToEliminate) === -1){
        remainingElements.push(positionToEliminate);
    };
});
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

//OUTPUT:
[ [ 1, 2, 3, 1, 2, 3 ], 2, 3 ]
[ 2, 3 ]
[ 1, 2, 3, 1, 2, 3 ]
[ 1, 1 ]

//Wherefore art thou
//Make a function that looks through an array of objects (first argument) and 
//    returns an array of all objects that have matching name and value pairs (second argument). 
//Each name and value pair of the source object has to be present in the object from the collection if it is to be included in the returned array.

//For example, if the first argument is 
//    '[{ first: "Romeo", last: "Montague" }, { first: "Mercutio", last: null }, { first: "Tybalt", last: "Capulet" }]', 
//    and the second argument is '{ last: "Capulet" }', then you must return the third object from the array (the first argument), 
//    because it contains the name and its value, that was passed on as the second argument.


//UNCHANGED CODE:

//    function whatIsInAName(collection, source) {
//      const arr = [];
//      // Only change code below this line


//      // Only change code above this line
//      return arr;
//    }

//    whatIsInAName([{ first: "Romeo", last: "Montague" }, { first: "Mercutio", last: null }, { first: "Tybalt", last: "Capulet" }], { last: "Capulet" });

//CHANGED CODE:
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\1st SOLUTION CODE
function whatIsInAName(collection, source) {
  const resultArr = [];
  // Only change code below this line
  let searchArr = collection.slice();
  let target = Object.values(arguments).splice(1);

  collection.forEach(searchArr => {
    //console.log(searchArr, Object.keys(source));
    for (let key in source) {
      if (searchArr[key] === source[key]) {
        console.log(searchArr);
        resultArr.push(searchArr);
      };
    };
  });

  // Only change code above this line
  return resultArr;
}

let result = whatIsInAName([{ "apple": 1, "bat": 2 }, { "bat": 2 }, { "apple": 1, "bat": 2, "cookie": 2 }], { "apple": 1, "bat": 2 });
console.log(result);
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
////////////////////////////////////////2nd SOLUTION
function whatIsInAName(collection, source) {
  const resultArr = [];
  // Only change code below this line
  let searchArr = collection.slice();
  let target = Object.values(arguments).splice(1);

  collection.forEach(searchArr => {
    let index = 0;
    //console.log(Object.keys(searchArr), Object.keys(source), target.indexOf(searchArr));
    for (let key in source) {
      if (searchArr[key] === source[key]) {
      index += 1;
      };
      console.log(index, searchArr[key], source[key], Object.keys(source).length);
      if (index === Object.keys(source).length) {
        //console.log(searchArr);
        resultArr.push(searchArr);
      } 
      /*if (searchArr[key] === source[key]) {
        //console.log(searchArr);
        resultArr.push(searchArr);
      }*/    
    };  
  });

  // Only change code above this line
  return resultArr;
}

let result = whatIsInAName([{"a": 1, "b": 2, "c": 3}], {"a": 1, "b": 9999, "c": 3});
console.log(result);
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\SOLUTION CODE:
function whatIsInAName(collection, source) {
  const resultArr = [];
  // Only change code below this line
  let searchArr = collection.slice();
  //let target = Object.values(arguments).splice(1);

  collection.forEach(searchArr => {
    let index = 0;
    //console.log(Object.keys(searchArr), Object.keys(source), target.indexOf(searchArr));
    for (let key in source) {
      if (searchArr[key] === source[key]) {
      index += 1;
      };
      console.log(index, searchArr[key], source[key], Object.keys(source).length);
      if (index === Object.keys(source).length) {
        //console.log(searchArr);
        resultArr.push(searchArr);
      };  
    };  
  });

  // Only change code above this line
  return resultArr;
}

let result = whatIsInAName([{ "apple": 1, "bat": 2 }, { "apple": 1 }, { "apple": 1, "bat": 2, "cookie": 2 }], { "apple": 1, "cookie": 2 });
console.log(result);
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

//OUTPUT:
[ { apple: 1, bat: 2 },
  { apple: 1, bat: 2 },
  { bat: 2 },
  { apple: 1, bat: 2, cookie: 2 },
  { apple: 1, bat: 2, cookie: 2 } ]
//////////////////////////////////////////SOLUTION OUTPUT:
1 1 1 2
1 undefined 2 2
1 1 1 2
1 undefined 2 2
1 1 1 2
2 2 2 2
[ { apple: 1, bat: 2, cookie: 2 } ]
//////////////////////////////////////////////////////////

//Spinal Tap Case
//Convert a string to spinal case. Spinal case is all-lowercase-words-joined-by-dashes.


//UNCHANGED CODE:

//    function spinalCase(str) {
//      return str;
//    }

//    spinalCase('This Is Spinal Tap');

//CHANGED CODE:
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\1st Part of SOLUTION CODE:
function spinalCase(str) {
  let strClone = str.slice();
  console.log(strClone);

  let camelCaseHandler = strClone.replace(/([a-z])([A-Z])/g, "$1 $2");
   //return camelCaseHandler;
  let underscoreCaseHandler = strClone.replace(/([a-z])(["_"])/g, "$1 ");
   return underscoreCaseHandler;
  let hypenHandler = strClone.replace(/([a-z])([\W])/g, "$1 ");
   //return hypenHandler;
  
  
  return str;
}

let result = spinalCase("The_Andy_Griffith_Show");
console.log(result);
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
////////////////////////////////////2nd Part of SOLUTION CODE:
function spinalCase(str) {
  let strClone = str.slice();
  console.log(strClone);
  console.log(strClone.length);
  let preSpinalCaseCamelStr = {};
  let preSpinalCaseUnderscoreStr = {};

  let camelCaseHandler = strClone.replace(/([a-z])([A-Z])/g, "$1 $2");
  console.log(camelCaseHandler.length);
  let hypenHandler = strClone.replace(/([a-z])([\W])/g, "$1 ");
  console.log(hypenHandler);
   if (strClone.length !== camelCaseHandler.length) {
      let lowerCaseHandler = camelCaseHandler.toLowerCase();
      preSpinalCaseCamelStr = lowerCaseHandler.slice();
      console.log(lowerCaseHandler);
      console.log(preSpinalCaseCamelStr);
   } else if (strClone.length === camelCaseHandler.length){
      let underscoreCaseHandler = strClone.replace(/([a-z])(["_"])/g, "$1 ");
      console.log(underscoreCaseHandler);
      let lowerCaseHandler = underscoreCaseHandler.toLowerCase();
      preSpinalCaseUnderscoreStr = underscoreCaseHandler.slice();
      console.log(lowerCaseHandler);
   }
  

   //return hypenHandler;
  /*if (strClone.length === camelCaseHandler.length) {
    let lowerCaseHandler = strClone.toLowerCase();
    console.log(lowerCaseHandler);
  };*/
    
   
  
  return str;
}

let result = spinalCase("The_Andy_Griffith_Show");
console.log(result);
//////////////////////////////////////////////////////////////////
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\SOLUTION CODE:
function spinalCase(str) {
  let strClone = str.slice();
  //console.log(strClone);
  //console.log(strClone.length);
  let preSpinalCaseCamelStr = {};
  let preSpinalCaseUnderscoreStr = {};
  let spinalCaseStr = {};

  let hypenHandler = strClone.replace(/([a-z])([\W])/g, "$1 ");
  //console.log(hypenHandler);


  let camelCaseHandler = strClone.replace(/([a-z])([A-Z])/g, "$1 $2");
  //console.log(camelCaseHandler.length);
  
 
   if (strClone.length !== camelCaseHandler.length) {
      let lowerCaseHandler = camelCaseHandler.toLowerCase();
      preSpinalCaseCamelStr = lowerCaseHandler.slice().replace(/([a-z])([\s])/g, "$1-");
      //console.log(lowerCaseHandler);
      //console.log(preSpinalCaseCamelStr);
      spinalCaseStr = preSpinalCaseCamelStr.slice();
      return spinalCaseStr;
   } else if (strClone.length === camelCaseHandler.length){
      let underscoreCaseHandler = strClone.replace(/([a-z])(["_"])/g, "$1 ");
      //console.log(underscoreCaseHandler);
      let lowerCaseHandler = underscoreCaseHandler.toLowerCase();
      preSpinalCaseUnderscoreStr = lowerCaseHandler.slice().replace(/([a-z])([\s])/g, "$1-");
      //console.log(lowerCaseHandler);
      //console.log(preSpinalCaseUnderscoreStr);
      spinalCaseStr = preSpinalCaseUnderscoreStr.slice();
      return spinalCaseStr;
   };
  
  return spinalCaseStr;
}

let result = spinalCase("This Is Spinal Tap");
console.log(result);
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
 
//OUTPUT:
\\\\\\\\\\\\\\\\\\\\\ONE
The_Andy_Griffith_Show
The Andy Griffith Show
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
///////////////////////TWO
The_Andy_Griffith_Show
22
22
The_Andy_Griffith_Show
The Andy Griffith Show
the andy griffith show
The_Andy_Griffith_Show
////////////////////////////////
\\\\\\\\\\\\\\\\\\\\\\\\\SOLUTION OUTPUT:
this-is-spinal-tap
FOR "thisIsSpinalTap" this-is-spinal-tap
FOR "The_Andy_Griffith_Show" the-andy-griffith-show
FOR "Teletubbies say Eh-oh"  teletubbies-say-eh-oh
FOR "AllThe-small Things"  all-the-small-things
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

//Pig Latin
//Pig Latin is a way of altering English Words. 
//The rules are as follows:

//- If a word begins with a consonant, take the first consonant or consonant cluster, move it to the end of the word, and add 'ay' to it.

//- If a word begins with a vowel, just add 'way' at the end.

//Translate the provided string to Pig Latin. 
//Input strings are guaranteed to be English words in all lowercase.


//UNCHANGED CODE:

//  function translatePigLatin(str) {
//    return str;
//  }

//  translatePigLatin("consonant");

//CHANGED CODE:
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\1st Analysis with regular expressions
function translatePigLatin(str) {
  console.log(str.match(/(^[aeiou])/));
  console.log(str.match(/(^[^aeiou])/));
  console.log(str.match(/(^[\w])([\w])([aeiou])/));
  console.log(str.match(/(^[\w])([\w])([^aeiou])/));
  console.log(str.match(/(^[\w])([\w]+)([aeiou])/));
  //"consonant"
  return str;
}

translatePigLatin("schwartz");
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
///////////////////////////////////////2nd Analysis
function translatePigLatin(str) {
  console.log(str.match(/(^[aeiou])/));
  console.log(str.match(/(^[^aeiou])/));
  console.log(str.match(/(^[\w])([\w])([aeiou])/));
  console.log(str.match(/(^[\w])([\w])([^aeiou])/));
  console.log(str.match(/(^[\w])([\w]+)([aeiou])/));
  console.log(str.replace(/(^[^aeiou])/, ""));
  console.log(str.concat("way"));
  //"consonant"
  return str;
}

translatePigLatin("eight");
///////////////////////////////////////////////
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\3rd Analysis
function translatePigLatin(str) {
  console.log(str.match(/(^[aeiou])/));
  console.log(str.match(/(^[^aeiou])/));
  console.log(str.match(/(^[\w])([\w])([aeiou])/));
  console.log(str.match(/(^[\w])([\w])([^aeiou])/));
  console.log(str.match(/(^[\w])([\w]+)([aeiou])/));
  console.log(str.replace(/(^[^aeiou])/, ""));
  console.log(str.concat("way"));
  let firstLetter = {};
  console.log(firstLetter = str.slice(0,1));
  console.log(firstLetter.concat("ay"));
  //"consonant" 
  return str;
}

translatePigLatin("consonant");
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
///////////////////////////////4th Analysis start of Solution
function translatePigLatin(str) {
  let pigLatinTarget = str.slice();
  console.log(pigLatinTarget);
  console.log(str.match(/(^[aeiou])/));
  console.log(str.match(/(^[^aeiou])/));
  let singleConsonant = {};
  console.log(str.match(/(^[\w])([\w])([aeiou])/));
  let clusterMatch = {};
  console.log(str.match(/(^[\w])([\w])([^aeiou])/));
  let noVowel = {};
  console.log(str.match(/(^[\w])([\w]+)([aeiou])/));
  let multiConsonant = {};
  console.log(str.replace(/(^[^aeiou])/, ""));
  
  let firstLetter = {};
  

  
      if (pigLatinTarget.match(/(^[aeiou])/) !== null && pigLatinTarget.match(/(^[\w])([\w])([aeiou])/) === null) {
        console.log(pigLatinTarget);
        console.log(pigLatinTarget.concat("way"));
        return pigLatinTarget.concat("way");
      } else if (pigLatinTarget.match(/(^[^aeiou])/) !== null && pigLatinTarget.match(/(^[\w])([\w])([aeiou])/) === null){
        console.log(pigLatinTarget);
        console.log(firstLetter = str.slice(0,1));
        console.log(firstLetter.concat("ay"));
        console.log(pigLatinTarget.slice(1));
        return pigLatinTarget.slice(1).concat(firstLetter.concat("ay"));
      } else if (pigLatinTarget.match(/(^[\w{2}])([aeiou])/) !== null && pigLatinTarget.match(/(^[\w])([\w])([^aeiou])/) === null) {
        console.log(pigLatinTarget);
      } else if (pigLatinTarget(/(^[\w{1, 4}])([aeiou])/) !== null && pigLatinTarget.match(/(^[\w])([\w]{1})([aeiou])/) === null) {
        console.log(pigLatinTarget);
      }
 

  //"consonant" 
  return str;
}

let result = translatePigLatin("consonant");
console.log(result);
/////////////////////////////////////////////////////////////////////////
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\SOLUTION CODE:
function translatePigLatin(str) {
  let pigLatinTarget = str.slice();
  console.log(pigLatinTarget);
  console.log(str.match(/(^[aeiou])/));
  console.log(str.match(/(^[^aeiou][aeiou])/));
  let singleConsonant = {};
  console.log(str.match(/(^[\w])([\w])([aeiou])/));
  let clusterMatch = {};
  console.log(str.match(/(^([^aeiou])([\w])([^aeiou])([\w])([^aeiou]))/));
  let noVowel = {};
  console.log(str.match(/(^[\w][\w])([^aeiou])([\w])([aeiou])/));
  let multiConsonant = {};
  //console.log(str.replace(/(^[^aeiou])/, ""));  (/(^[\w])([^aeiou])([\w])([aeiou])/)
  
  let firstLetter = {};
  

  
      if (pigLatinTarget.match(/(^[aeiou])/) !== null && pigLatinTarget.match(/(^[\w])([\w])([aeiou])/) === null) {
        //console.log(str);
        //console.log(str.concat("way"));
        return pigLatinTarget.concat("way");
      } else if (pigLatinTarget.match(/(^[^aeiou][aeiou])/) !== null && pigLatinTarget.match(/(^[\w])([^aeiou])([\w])([aeiou])/) === null){
        //console.log(str);
        //console.log(firstLetter = str.slice(0,1));
        //console.log(firstLetter.concat("ay"));
        //console.log(pigLatinTarget.slice(1));
        let endingStr = (firstLetter = str.slice(0,1)).concat("ay");
        return pigLatinTarget.slice(1).concat(endingStr);
      } else if (pigLatinTarget.match(/(^[\w])([\w])([aeiou])/) !== null && pigLatinTarget.match(/(^[\w][\w])([^aeiou])([\w])([aeiou])/) === null) {
        //console.log(pigLatinTarget);
        //console.log(firstLetter = str.slice(0,2).concat("ay"));
        let endingStr = firstLetter = str.slice(0,2).concat("ay");
        return pigLatinTarget.slice(2).concat(endingStr);
      } else if (pigLatinTarget.match(/(^[\w][\w])([^aeiou])([\w])([aeiou])/) !== null && pigLatinTarget.match(/(^[\w])([\w])([aeiou])/) === null) {
        //console.log(pigLatinTarget);
        let endingStr = firstLetter = str.slice(0,4).concat("ay");
        return pigLatinTarget.slice(4).concat(endingStr);
      } else if (pigLatinTarget.match(/(^([^aeiou])([\w])([^aeiou])([\w])([^aeiou]))/) !== null) {
        //console.log(pigLatinTarget);
        return pigLatinTarget.concat("ay");
      };
 

  //"consonant" 
  return str;
}

let result = translatePigLatin("consonant");
console.log(result);
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
//OUTPUT:
onsonantcay
aliforniacay
aragraphspay
oveglay
algorithmway
eightway
artzschway
rhythmay

//Search and Replace
//Perform a search and replace on the sentence using the arguments provided and return the new sentence.

//First argument is the sentence to perform the search and replace on.

//Second argument is the word that you will be replacing (before).

//Third argument is what you will be replacing the second argument with (after).

//Note: Preserve the case of the first character in the original word when you are replacing it. 
//For example if you mean to replace the word 'Book' with the word 'dog', it should be replaced as 'Dog'


//UNCHANGED CODE:

//    function myReplace(str, before, after) {
//      return str;
//    }

//    myReplace("A quick brown fox jumped over the lazy dog", "jumped", "leaped");

//CHANGED CODE:
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\1st Analysis using 'Object' and 'arguments' to evaluate data
function myReplace(str, before, after) {
  //console.log(arguments);
  //console.log(Object.values(arguments)[0]);
  //console.log(Object.values(arguments).slice(1));
  let wordsToSwap = Object.values(arguments).slice(1);
  let strToChange = Object.values(arguments)[0];
  let strToChangeIndividualWords = strToChange.split(" ");
  //console.log(strToChangeIndividualWords);

  for (let i = 0; i < strToChangeIndividualWords.length; i++) {
    console.log(strToChangeIndividualWords[i]);
  }
  return str;
}

myReplace("A quick brown fox jumped over the lazy dog", "jumped", "leaped");
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
//////////////////////////////////////1st SOLUTION CODE:
function myReplace(str, before, after) {
  //console.log(arguments);
  //console.log(Object.values(arguments)[0]);
  //console.log(Object.values(arguments).slice(1));
  let wordsToSwap = Object.values(arguments).slice(1);
  let strToChange = Object.values(arguments)[0];
  let arrToChangeIndividualWords = strToChange.split(" ");
  //console.log(strToChangeIndividualWords);, Object.keys(wordsToSwap), Object.keys(strToChangeIndividualWords[i])
  let strToChangeIndividualWords = {};
  let newSentence = {};

  for (let i = 0; i < arrToChangeIndividualWords.length; i++) {
    if (wordsToSwap[0] === arrToChangeIndividualWords[i]) {
      console.log(arrToChangeIndividualWords[i], wordsToSwap);
      strToChangeIndividualWords = arrToChangeIndividualWords.splice([i], 1, wordsToSwap[1]).slice().toString();
      console.log(strToChangeIndividualWords)
      newSentence = arrToChangeIndividualWords.slice();
      console.log(newSentence.toString().replace(/([\W])/g, " "));
    }
  }
  return str;
}

let result = myReplace("A quick brown fox jumped over the lazy dog", "jumped", "leaped");
console.log(result);
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\2nd SOLUTION CODE:
function myReplace(str, before, after) {
  //console.log(arguments);
  //console.log(Object.values(arguments)[0]);
  //console.log(Object.values(arguments).slice(1));
  let wordsToSwap = Object.values(arguments).slice(1);
  let strToChange = Object.values(arguments)[0];
  let arrToChangeIndividualWords = strToChange.split(" ");
  //console.log(strToChangeIndividualWords);, Object.keys(wordsToSwap), Object.keys(strToChangeIndividualWords[i]) .toString()
  let strToChangeIndividualWords = {};
  let newSentence = {};
  let firstLetter = {};
  //console.log(Object.values(wordsToSwap[0])[0].match(/^([A-Z])/));
  //console.log(Object.values(wordsToSwap[1])[0].match(/^([A-Z])/));
  if (Object.values(wordsToSwap[0])[0].match(/^([A-Z])/) !== null && Object.values(wordsToSwap[1])[0].match(/^([A-Z])/) === null) {
     firstLetter = wordsToSwap[1].toUpperCase().split("")[0];
      console.log(firstLetter);
      console.log(wordsToSwap[1].replace(/^([\w])/, firstLetter));
  }
  

  for (let i = 0; i < arrToChangeIndividualWords.length; i++) {
    if (wordsToSwap[0] === arrToChangeIndividualWords[i]) {
      console.log(arrToChangeIndividualWords[i], wordsToSwap);
      strToChangeIndividualWords = arrToChangeIndividualWords.splice([i], 1, wordsToSwap[1]).slice().toString();
      console.log(strToChangeIndividualWords)
      newSentence = arrToChangeIndividualWords.slice();
      console.log(newSentence.toString().replace(/([\W])/g, " "));
    }
  }
  return newSentence.toString().replace(/([\W])/g, " ");
}
//"A quick brown fox jumped over the lazy dog", "jumped", "leaped"  .replace(/^([\w])/, firstLetter))
let result = myReplace("A quick brown fox jumped over the lazy dog", "jumped", "leaped");
console.log(result);
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
////////////////////////////////////////FINAL SOLUTION CODE:
function myReplace(str, before, after) {
  //console.log(arguments);
  //console.log(Object.values(arguments)[0]);
  //console.log(Object.values(arguments).slice(1));
  let wordsToSwap = Object.values(arguments).slice(1);
  let strToChange = Object.values(arguments)[0];
  let arrToChangeIndividualWords = strToChange.split(" ");
  //console.log(strToChangeIndividualWords);, Object.keys(wordsToSwap), Object.keys(strToChangeIndividualWords[i]) .toString()  .replace(/^([\w])/, firstLetter)
  let strToChangeIndividualWords = {};
  let newSentence = {};
  let firstLetter = {};
  let caseHandler = {};
  //console.log(Object.values(wordsToSwap[0])[0].match(/^([A-Z])/));
  //console.log(Object.values(wordsToSwap[1])[0].match(/^([A-Z])/));
  if (Object.values(wordsToSwap[0])[0].match(/^([A-Z])/) !== null && Object.values(wordsToSwap[1])[0].match(/^([A-Z])/) === null) {
     firstLetter = wordsToSwap[1].toUpperCase().split("")[0];
      console.log(firstLetter);
      console.log(wordsToSwap[1].replace(/^([\w])/, firstLetter));
      caseHandler = wordsToSwap[1].replace(/^([\w])/, firstLetter);
  } else if (Object.values(wordsToSwap[0])[0].match(/^([a-z])/) !== null && Object.values(wordsToSwap[1])[0].match(/^([a-z])/) === null) {
     firstLetter = wordsToSwap[1].toLowerCase().split("")[0];
      console.log(firstLetter);
      console.log(wordsToSwap[1].replace(/^([\w])/, firstLetter));
      caseHandler = wordsToSwap[1].replace(/^([\w])/, firstLetter);
  }
  console.log(Object.values(caseHandler)[0]);

  for (let i = 0; i < arrToChangeIndividualWords.length; i++) {
    if (wordsToSwap[0] === arrToChangeIndividualWords[i] && Object.values(caseHandler)[0] === undefined) {
      //console.log(arrToChangeIndividualWords[i], wordsToSwap);
      strToChangeIndividualWords = arrToChangeIndividualWords.splice([i], 1, wordsToSwap[1]).slice().toString();
      //console.log(strToChangeIndividualWords)
      newSentence = arrToChangeIndividualWords.slice();
      console.log(newSentence.toString().replace(/([\W])/g, " "));
    } else if (wordsToSwap[0] === arrToChangeIndividualWords[i]) {
      //console.log(arrToChangeIndividualWords[i], wordsToSwap);
      strToChangeIndividualWords = arrToChangeIndividualWords.splice([i], 1, caseHandler).slice().toString();
      //console.log(strToChangeIndividualWords)
      newSentence = arrToChangeIndividualWords.slice();
      console.log(newSentence.toString().replace(/([\W])/g, " "));
    }
  }
  return newSentence.toString().replace(/([\W])/g, " ");
}
//"A quick brown fox jumped over the lazy dog", "jumped", "leaped"
let result = myReplace("He is Sleeping on the couch", "Sleeping", "sitting");
console.log(result);
//////////////////////////////////////////////////////////////////////////////

//OUTPUT:
\\\\\\\\\\\\\\\\\\\1st Solution:
jumped [ 'jumped', 'leaped' ]
jumped
A quick brown fox leaped over the lazy dog
A quick brown fox jumped over the lazy dog
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
////////////////////FINAL SOLUTION OUTPUT
A quick brown fox leaped over the lazy dog
Let us go to the mall
He is Sitting on the couch
I think we should look down there
This has a spelling error
//////////////////////////////////////////////////////

//DNA Pairing
//Pairs of DNA strands consist of nucleobase pairs. 
//Base pairs are represented by the characters "AT" and "CG", which form building blocks of the DNA double helix.

//The DNA strand is missing the pairing element. 
//Write a function to match the missing base pairs for the provided DNA strand. 
//For each character in the provided string, find the base pair character. 
//Return the results as a 2d array.

//For example, for the input 'GCG', return '[["G", "C"], ["C","G"], ["G", "C"]]'

//The character and its pair are paired up in an array, and all the arrays are grouped into one encapsulating array.


//UNCHANGED CODE:

//    function pairElement(str) {
//      return str;
//    }

//    pairElement("GCG");

//CHANGED CODE:
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\1st Analysis
function pairElement(str) {
  let singleStrandDNAStr = str.slice();
  console.log(singleStrandDNAStr.split(""));
  let singleStrandDNAArr = [];
  for (let i = 0; i < singleStrandDNAStr.split("").length; i++) {
    singleStrandDNAArr.push(singleStrandDNAStr.split("")[i]);
    console.log(singleStrandDNAArr);
  }
  return str;
}

pairElement("GCG");
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
////////////////////////////////2nd Analysis
function pairElement(str) {
  let singleStrandDNAStr = str.slice();
  console.log(singleStrandDNAStr.split(""));
  let singleStrandDNAArr = [];
  for (let i = 0; i < singleStrandDNAStr.split("").length; i++) {
    //singleStrandDNAArr.push(singleStrandDNAStr.split("")[i]);
    
    if (singleStrandDNAStr.split("")[i] === "A") {
      console.log(singleStrandDNAStr.split("")[i], "T");
      singleStrandDNAArr.push(singleStrandDNAStr.split("")[i]);
      singleStrandDNAArr.push("T");
    } else if (singleStrandDNAStr.split("")[i] === "T") {
      console.log(singleStrandDNAStr.split("")[i], "A");
      singleStrandDNAArr.push(singleStrandDNAStr.split("")[i]);
      singleStrandDNAArr.push("A");
    } else if (singleStrandDNAStr.split("")[i] === "C") {
      console.log(singleStrandDNAStr.split("")[i], "G");      
      singleStrandDNAArr.push(singleStrandDNAStr.split("")[i]);
      singleStrandDNAArr.push("G");
    } else if (singleStrandDNAStr.split("")[i] === "G") {
      console.log(singleStrandDNAStr.split("")[i], "C");
      singleStrandDNAArr.push(singleStrandDNAStr.split("")[i]);
      singleStrandDNAArr.push("C");
    }  
  }console.log(singleStrandDNAArr);
  return str;
}
//"GCG"
let result = pairElement("ATCGA");
console.log(result);
///////////////////////////////////////////////////////
\\\\\\\\\\\\\\\\\\\\\\\\\3rd Analysis
function pairElement(str) {
  let singleStrandDNAStr = str.slice();
  console.log(singleStrandDNAStr.split(""));
  let singleStrandDNAArr = [];
  let pairAT = [];
  let pairTA = [];
  let pairCG = [];
  let pairGC = [];
  let pairStrandDNAArr = [];
  for (let i = 0; i < singleStrandDNAStr.split("").length; i++) {
    //singleStrandDNAArr.push(singleStrandDNAStr.split("")[i]);
    
    if (singleStrandDNAStr.split("")[i] === "A") {
      console.log(singleStrandDNAStr.split("")[i], "T");
      //singleStrandDNAArr.push(singleStrandDNAStr.split("")[i]);
      //singleStrandDNAArr.push("T");
      pairAT.push(singleStrandDNAStr.split("")[i]);
      pairAT.push("T");
      pairStrandDNAArr.push(pairAT);
    } else if (singleStrandDNAStr.split("")[i] === "T") {
      console.log(singleStrandDNAStr.split("")[i], "A");
      //singleStrandDNAArr.push(singleStrandDNAStr.split("")[i]);
      //singleStrandDNAArr.push("A");
      pairTA.push(singleStrandDNAStr.split("")[i]);
      pairTA.push("A");
      pairStrandDNAArr.push(pairTA);
    } else if (singleStrandDNAStr.split("")[i] === "C") {
      console.log(singleStrandDNAStr.split("")[i], "G");      
      //singleStrandDNAArr.push(singleStrandDNAStr.split("")[i]);
      //singleStrandDNAArr.push("G");
      pairCG.push(singleStrandDNAStr.split("")[i]);
      pairCG.push("G");
      pairStrandDNAArr.push(pairCG);
    } else if (singleStrandDNAStr.split("")[i] === "G") {
      console.log(singleStrandDNAStr.split("")[i], "C");
      //singleStrandDNAArr.push(singleStrandDNAStr.split("")[i]);
      //singleStrandDNAArr.push("C");
      pairGC.push(singleStrandDNAStr.split("")[i]);
      pairGC.push("C");
      pairStrandDNAArr.push(pairGC);
    }  
  }console.log(pairStrandDNAArr);
  return str;
}
//"GCG"
let result = pairElement("ATCGA");
console.log(result);
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
///////////////////////////SOLUTION CODE:
function pairElement(str) {
  let singleStrandDNAStr = str.slice();
  //console.log(singleStrandDNAStr.split(""));
  //let singleStrandDNAArr = [];
  let pairAT = [];
  let pairTA = [];
  let pairCG = [];
  let pairGC = [];
  let pairStrandDNAArr = [];
  for (let i = 0; i < singleStrandDNAStr.split("").length; i++) {
    //singleStrandDNAArr.push(singleStrandDNAStr.split("")[i]);
    
    if (singleStrandDNAStr.split("")[i] === "A") {
      //console.log(singleStrandDNAStr.split("")[i], "T");
      //singleStrandDNAArr.push(singleStrandDNAStr.split("")[i]);
      //singleStrandDNAArr.push("T");
      if (Object.keys(pairAT)[1] === undefined) {
      pairAT.push(singleStrandDNAStr.split("")[i]);
      pairAT.push("T");
      }
      pairStrandDNAArr.push(pairAT);
    } else if (singleStrandDNAStr.split("")[i] === "T") {
      //console.log(singleStrandDNAStr.split("")[i], "A");
      //singleStrandDNAArr.push(singleStrandDNAStr.split("")[i]);
      //singleStrandDNAArr.push("A");
      if (Object.keys(pairTA)[1] === undefined) {
      pairTA.push(singleStrandDNAStr.split("")[i]);
      pairTA.push("A");
      }
      pairStrandDNAArr.push(pairTA);
    } else if (singleStrandDNAStr.split("")[i] === "C") {
      //console.log(singleStrandDNAStr.split("")[i], "G");      
      //singleStrandDNAArr.push(singleStrandDNAStr.split("")[i]);
      //singleStrandDNAArr.push("G");
      if (Object.keys(pairCG)[1] === undefined) {
        pairCG.push(singleStrandDNAStr.split("")[i]);
        pairCG.push("G");
        }
      pairStrandDNAArr.push(pairCG);
    } else if (singleStrandDNAStr.split("")[i] === "G") {
      //console.log(singleStrandDNAStr.split("")[i], "C");
      //singleStrandDNAArr.push(singleStrandDNAStr.split("")[i]);
      //singleStrandDNAArr.push("C");
      if (Object.keys(pairGC)[1] === undefined) {
        pairGC.push(singleStrandDNAStr.split("")[i]);
        pairGC.push("C");
        }
      pairStrandDNAArr.push(pairGC);
    }  
  }
  //console.log(Object.keys(pairGC)[2]);
  //console.log(Object.keys(pairStrandDNAArr));
  //console.log(pairStrandDNAArr);
  return pairStrandDNAArr;
}
//"GCG"
let result = pairElement("TTGAG");
console.log(result);
////////////////////////////////////////////////////

//OUTPUT:
\\\\\\\\\\\\\\\\\\1st Analysis Output
[ 'G', 'C', 'G' ]
[ 'G' ]
[ 'G', 'C' ]
[ 'G', 'C', 'G' ]
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
////////////////////2nd 
[ 'A', 'T', 'C', 'G', 'A' ]
A T
T A
C G
G C
A T
[ 'A', 'T', 'T', 'A', 'C', 'G', 'G', 'C', 'A', 'T' ]
ATCGA
/////////////////////////////////////////////////////////
\\\\\\\\\\\\\\\\\\\\\\\\\\\3rd
[ 'A', 'T', 'C', 'G', 'A' ]
A T
T A
C G
G C
A T
[ [ 'A', 'T', 'A', 'T' ],
  [ 'T', 'A' ],
  [ 'C', 'G' ],
  [ 'G', 'C' ],
  [ 'A', 'T', 'A', 'T' ] ]
ATCGA
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
//////////////////SOLUTION OUTPUT:
[ [ 'G', 'C' ], [ 'C', 'G' ], [ 'G', 'C' ] ]
[ [ 'A', 'T' ],
  [ 'T', 'A' ],
  [ 'C', 'G' ],
  [ 'G', 'C' ],
  [ 'A', 'T' ] ]
[ [ 'T', 'A' ],
  [ 'T', 'A' ],
  [ 'G', 'C' ],
  [ 'A', 'T' ],
  [ 'G', 'C' ] ]
[ [ 'C', 'G' ],
  [ 'T', 'A' ],
  [ 'C', 'G' ],
  [ 'T', 'A' ],
  [ 'A', 'T' ] ]
///////////////////////////////////////////////////////////////

//Missing letters
//Find the missing letter in the passed letter range and return it.

//If all letters are present in the range, return 'undefined'.


//UNCHANGED CODE:

//    function fearNotLetter(str) {
//      return str;
//    }

//    fearNotLetter("abce");

//CHANGED CODE:
\\\\\\\\\\\\\\\\\\\\\\\\\\1st Analysis
function fearNotLetter(str) {
  let alphabet = "abcdefghijklmnopqrstuvwxyz".split("");
  //console.log(Object.keys(alphabet));
  let letterRange = str.slice().split("");
  console.log(letterRange);
  let missingLetter = [];
  for (let i = 0; i < alphabet.length; i++) {
    /*if (letterRange[i] !== alphabet[i]) {
      console.log(alphabet[i])
    }*/
    if (letterRange[i] === alphabet[i]) {
      console.log(alphabet[i]);
      console.log(alphabet[i += 1]);
      missingLetter.push(alphabet[i += 2]);
      console.log(missingLetter.toString());
    }
  }
  return str;
}

fearNotLetter("abce");
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
/////////////////////////////2nd Analysis
function fearNotLetter(str) {
  let alphabet = "abcdefghijklmnopqrstuvwxyz".split("");
  //console.log(Object.keys(alphabet));
  let letterRange = str.slice().split("");
  
  console.log(letterRange);
  let missingLetter = [];
  
  for (let i = 0; i < alphabet.length; i++) {
    /*if (letterRange[i] !== alphabet[i]) {
      console.log(alphabet[i])
    }*/
    //console.log(Object.values((letterRange.indexOf(i) !== -1)))
    if (letterRange[i] === alphabet[i]) {
      //console.log(alphabet[i]);
      //console.log(alphabet[i += 1]);
      missingLetter.push(alphabet[i += 1]);
      console.log(missingLetter.pop().toString());
    }
  }
  return str;
}

fearNotLetter("abcdefghjklmno");
////////////////////////////////////////////////////////////
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\3rd SOLUTION CODE 1:
function fearNotLetter(str) {
  let alphabet = "abcdefghijklmnopqrstuvwxyz".split("");
  //console.log(Object.keys(alphabet)); .match(/^([d])/)
  let letterRange = str.slice().split("");
  let missingLetter = [];
  
  for (let i = 0; i < alphabet.length; i++) {
    if (alphabet[i] === letterRange[i]) {
      missingLetter = alphabet[i + 1];
      
    }
  }console.log(missingLetter);
  return str;
}

let result = fearNotLetter("abcdefghijklmnopqrstuvwxyz");
console.log(result);
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
/////////////////////////////////4th SOLUTION CODE:
function fearNotLetter(str) {
  let alphabet = "abcdefghijklmnopqrstuvwxyz".split("");
  //console.log(Object.keys(alphabet)); .match(/^([d])/)
  let letterRange = str.slice().split("");
  let missingLetter = false;
  
  console.log(Boolean(missingLetter))

  for (let i = 0; i < alphabet.length; i++) {
    if (alphabet[i] === letterRange[i]) {
      missingLetter = alphabet[i + 1]; 
      //return missingLetter;   
    }
  } 
  if (Boolean(missingLetter) === false) {
    for (let j = 0; j < alphabet.length; j++) {
      let individualLetter = alphabet[j];
      if (letterRange.indexOf(individualLetter) !== -1 && letterRange[j] !== undefined) {
        //console.log(alphabet[j + 1]);
        missingLetter = alphabet[j + 1];
        //return missingLetter;
      }
    }
    }
  
  console.log(Boolean(missingLetter));
  
  return missingLetter;
}

let result = fearNotLetter("abcdefghijklmnopqrstuvwxyz");
console.log(result);
///////////////////////////////////////////////////////////////////////////////
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\SOLUTION CODE:
function fearNotLetter(str) {
  let alphabet = "abcdefghijklmnopqrstuvwxyz".split("");
  //console.log(Object.keys(alphabet)); .match(/^([d])/)
  let letterRange = str.slice().split("");
  let missingLetter = false;
  
  //console.log(Boolean(missingLetter))

  for (let i = 0; i < alphabet.length; i++) {
    if (alphabet[i] === letterRange[i]) {
      missingLetter = alphabet[i + 1]; 
      //return missingLetter;   
    }
  }; 
  if (Boolean(missingLetter) === false) {
      for (let j = 0; j < alphabet.length; j++) {
        let individualLetter = alphabet[j];
        if (letterRange.indexOf(individualLetter) !== -1 && letterRange[j] !== undefined) {
          //console.log(alphabet[j + 1]);
          missingLetter = alphabet[j + 1];
          //return missingLetter;
        }
      }
    };
    if (Boolean(missingLetter) === false) {
      for (let j = 0; j < alphabet.length; j++) {
        let individualLetter = alphabet.reverse()[j];
        if (letterRange.reverse().indexOf(individualLetter) !== -1 && letterRange.reverse()[j] !== undefined) {
          //console.log(alphabet[j + 1]);
          missingLetter = alphabet[j + 1];
          //return missingLetter;
        }
      }
    };
  
  console.log(alphabet.reverse());
  
  return missingLetter;
}

let result = fearNotLetter("stvwx");
console.log(result);
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

//OUTPUT:
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\3rd SOLUTION CODE 1 OUTPUT
undefined
OR
i
OR
d
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
///////////////////////////////////4th SOLUTION CODE 2 OUTPUT
false
false
undefined
OR
e
OR
i
OR
d
//////////////////////////////////////////////////////////////////
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\SOLUTION OUTPUT:
u
OR
undefined
OR
e
OR
i
OR
d
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


//Sorted Union
//Write a function that takes two or more arrays and returns a new array of unique values in the order of the original provided arrays.

//In other words, all values present from all arrays should be included in their original order, but with no duplicates in the final array.

//The unique numbers should be sorted by their original order, but the final array should not be sorted in numerical order.

//Check the assertion tests for examples.


//UNCHANGED CODE:

//    function uniteUnique(arr) {
//      return arr;
//    }

//    uniteUnique([1, 3, 2], [5, 2, 1, 4], [2, 1]);

//CHANGED CODE:
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\1st Analysis
function uniteUnique(arr) {
  console.log(arguments[0].length);
  let longestArray = {};
  let shortestArray = {};
  let mediumArray = {};
  for (let i = 0; i < arguments.length; i++) {
    if (arguments[i].length > arguments.length) {
      longestArray = arguments[i];
      console.log(longestArray);
    } else if (arguments[i].length < arguments.length) {
      shortestArray = arguments[i];
      console.log(shortestArray);
    } else if (arguments[i].length === arguments.length) {
      mediumArray = arguments[i];
      console.log(mediumArray);
      }
  };
  

  return arr;
}

let result = uniteUnique([1, 3, 2], [5, 2, 1, 4], [2, 1]);
console.log(result);
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
///////////////////////////////////////2nd Analysis
function uniteUnique(arr) {
  console.log(arguments[0].length);
  let longestArray = {};
  let shortestArray = {};
  let mediumArray = {};
  let uniqueArray = {};
  for (let i = 0; i < arguments.length; i++) {
    if (arguments[i].length > arguments.length) {
      longestArray = arguments[i];
      console.log(longestArray);
    } else if (arguments[i].length < arguments.length) {
      shortestArray = arguments[i];
      console.log(shortestArray);
    } else if (arguments[i].length === arguments.length) {
      mediumArray = arguments[i];
      console.log(mediumArray);
      }
  };
  console.log(typeof arguments[0][1])
  for (let j = 0; j < longestArray.length; j++) {
    let individualValue = longestArray[j];
    if (typeof individualValue !== typeof arguments[0][j]) {
      console.log(individualValue)
    }
  }

  return arr;
}

let result = uniteUnique([1, 3, 2], [5, 2, 1, 4], [2, 1]);
console.log(result);
////////////////////////////////////////////////////////////////
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\SOLUTION ONE
function uniteUnique(arr) {
  console.log(arguments[0].length);
  let longestArray = {};
  let shortestArray = {};
  let mediumArray = {};
  let uniqueArray = [];
  for (let i = 0; i < arguments.length; i++) {
    if (i <= arguments[0].length) {
      uniqueArray.push(arguments[0][i]);
    };
    if (arguments[i].length > arguments.length) {
      longestArray = arguments[i];
      console.log(longestArray);
    } else if (arguments[i].length < arguments.length) {
      shortestArray = arguments[i];
      console.log(shortestArray);
    } else if (arguments[i].length === arguments.length) {
      mediumArray = arguments[i];
      console.log(mediumArray);
      }
  };
  let highValue = {};
  let valueOutsideScope = {};
  //console.log(typeof arguments[0][1])
  for (let j = 0; j < longestArray.length; j++) {
    
    let individualValue = longestArray[j];
    
    if (individualValue > arguments[0][j]) {
      
      highValue = individualValue;
      console.log(highValue);

    } else if (typeof individualValue !== typeof arguments[0][j]) {
      
      valueOutsideScope = individualValue;
      console.log(valueOutsideScope);

    }    
  };
  uniqueArray.push(highValue, valueOutsideScope);
  console.log(uniqueArray);
  return uniqueArray;
}

let result = uniteUnique([1, 3, 2], [5, 2, 1, 4], [2, 1]);
console.log(result);
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
///////////////////////////////////SOLUTION TWO ANALYSIS
function uniteUnique(arr) {
  console.log(arguments[0].length);
  let longestArray = {};
  let shortestArray = {};
  let mediumArray = {};
  let uniqueArray = [];

  if (arguments.length === arguments[0].length) {

  for (let i = 0; i < arguments.length; i++) {
    if (i <= arguments[0].length) {
      uniqueArray.push(arguments[0][i]);
    };
    if (arguments[i].length > arguments.length) {
      longestArray = arguments[i];
      console.log(longestArray);
    } else if (arguments[i].length < arguments.length) {
      shortestArray = arguments[i];
      console.log(shortestArray);
    } else if (arguments[i].length === arguments.length) {
      mediumArray = arguments[i];
      console.log(mediumArray);
      }
  };
  let highValue = {};
  let valueOutsideScope = {};
  //console.log(typeof arguments[0][1])
  for (let j = 0; j < longestArray.length; j++) {
    
    let individualValue = longestArray[j];
    
    if (individualValue > arguments[0][j]) {
      
      highValue = individualValue;
      console.log(highValue);

    } else if (typeof individualValue !== typeof arguments[0][j]) {
      
      valueOutsideScope = individualValue;
      console.log(valueOutsideScope);

    }    
  };
  uniqueArray.push(highValue, valueOutsideScope);
  console.log(uniqueArray);
  return uniqueArray;
} else if (arguments.length < arguments[0].length) {
    //console.log(arguments);
    let firstArray = arguments[0];
    //console.log(firstArray);
    let secondArray = arguments[1];
    //console.log(secondArray);

    for (let individualValue in firstArray) {
      if (firstArray.length === secondArray.length) {
        if (firstArray[0] !== secondArray.reverse()) {
        console.log(secondArray)
        }
      }
    }

    /*for (let k = 0; k < firstArray.length; k++) {
        if (firstArray[k] !== secondArray[k]) {
          console.log(secondArray[k]);
        }
      }
    firstArray.forEach(individualValue => {
        if (secondArray === undefined) {
          console.log(secondArray);
        }
    });*/
} else if (arguments.length > arguments[0].length) {
  //console.log(arguments);
}
}; 
  

let result = uniteUnique([1, 2, 3], [5, 2, 1]);
console.log(result);
//////////////////////////////////////////////////////////////////
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\SOLUTION TWO
function uniteUnique(arr) {
  console.log(arguments[0].length);
  let longestArray = {};
  let shortestArray = {};
  let mediumArray = {};
  let uniqueArray = [];
  let highValue = {};
  let valueOutsideScope = {};

  if (arguments.length === arguments[0].length) {

  for (let i = 0; i < arguments.length; i++) {
    if (i <= arguments[0].length) {
      uniqueArray.push(arguments[0][i]);
    };
    if (arguments[i].length > arguments.length) {
      longestArray = arguments[i];
      console.log(longestArray);
    } else if (arguments[i].length < arguments.length) {
      shortestArray = arguments[i];
      console.log(shortestArray);
    } else if (arguments[i].length === arguments.length) {
      mediumArray = arguments[i];
      console.log(mediumArray);
      }
  };
  
  //console.log(typeof arguments[0][1])
  for (let j = 0; j < longestArray.length; j++) {
    
    let individualValue = longestArray[j];
    
    if (individualValue > arguments[0][j]) {
      
      highValue = individualValue;
      console.log(highValue);

    } else if (typeof individualValue !== typeof arguments[0][j]) {
      
      valueOutsideScope = individualValue;
      console.log(valueOutsideScope);

    }    
  };
  uniqueArray.push(highValue, valueOutsideScope);
  console.log(uniqueArray);
  return uniqueArray;
} else if (arguments.length < arguments[0].length) {
    //console.log(arguments);
    let firstArray = arguments[0];
    //console.log(firstArray);
    let secondArray = arguments[1];
    //console.log(secondArray);

    if (firstArray.length === secondArray.length) {
      if (firstArray[0] !== secondArray[0]) {
        let reverseSecondArray = secondArray.reverse()
        if (firstArray[0] === secondArray[0] && firstArray[1] === secondArray[1]) {  
              valueOutsideScope = secondArray.pop();
              for (let k = 0; k < firstArray.length; k++) {
              uniqueArray.push(firstArray[k]);
              };
              uniqueArray.push(valueOutsideScope);
            };
        };
      console.log(uniqueArray);
      return uniqueArray;
    };

    /*
        if (firstArray[k] !== secondArray[k]) {
          console.log(secondArray[k]);
        }
      }
    firstArray.forEach(individualValue => {
        if (secondArray === undefined) {
          console.log(secondArray);
        }
    });*/
} else if (arguments.length > arguments[0].length) {
  //console.log(arguments);
}
}; 
  

let result = uniteUnique([1, 2, 3], [5, 2, 1]);
console.log(result);
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
////////////////////////////////////////THE REAL SOLUTION CODE PART1:
function uniteUnique(arr) {
  //console.log(arguments[0].length);
  //console.log(Object.values(arguments).toString());
  let argumentsToString = Object.values(arguments).toString();
  //console.log(argumentsToString.match(/([1,2,3])/g).toString().split(""));
  let frontEndHandler = argumentsToString.match(/([1,2,3])/g).toString().split("");
  //console.log(Object.keys(frontEnd));
  let frontEndHandlerArray = [];
  let frontEndNumbers = [];
  for (let i = 0; i < frontEndHandler.length; i++) {
    if (frontEndHandler[i] >= 1) {
      frontEndHandlerArray.push(frontEndHandler[i]);
    };
  };
  //console.log(frontEndNumbers);
  //console.log(typeof arguments[0].toString())
  for (let j = 0; j < arguments[0].length; j++) {
    //console.log(typeof frontEndNumbers[j])
    if (frontEndHandlerArray[j] === arguments[0][j].toString()){
      frontEndNumbers.push(frontEndHandlerArray[j]);
      //console.log(frontEndNumbers);
      if (frontEndNumbers.length > 3) {
        frontEndNumbers.pop();
      }
      //console.log(frontEndNumbers);
    }
  }
  
  let argumentsToStringRegExpA = argumentsToString.match(/[^1,2,3]/g);
  let argumentsToStringRegExpAToArray = argumentsToStringRegExpA.toString().split(",");
  console.log(argumentsToStringRegExpAToArray);

  for (let k = 0; k < argumentsToStringRegExpAToArray.length; k++) {
    frontEndNumbers.push(argumentsToStringRegExpAToArray[k]);
  };
  
  
  console.log(frontEndNumbers);
}; 
  

let result = uniteUnique([1, 3, 2, 3], [5, 2, 1, 4], [2, 1]);
console.log(result);
//////////////////////////////////////////////////////////////////////////////////////////////////
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\THE SOLUTION CODE PART2:
function uniteUnique(arr) {
  console.log(arr.length);
  //console.log(Object.values(arguments).toString());
  let argumentsToString = Object.values(arguments).toString();
  //console.log(argumentsToString.match(/([1,2,3])/g).toString().split(""));
  let frontEndHandler = argumentsToString.match(/([1,2,3])/g).toString().split("");
  //console.log(Object.keys(frontEnd));
  let frontEndHandlerArray = [];
  let frontEndNumbers = [];
  for (let i = 0; i < frontEndHandler.length; i++) {
    if (frontEndHandler[i] >= 1) {
      frontEndHandlerArray.push(frontEndHandler[i]);
    };
  };
  //console.log(frontEndNumbers);
  //console.log(typeof arguments[0].toString())
  for (let j = 0; j < arguments[0].length; j++) {
    //console.log(typeof frontEndNumbers[j])
    if (frontEndHandlerArray[j] === arguments[0][j].toString()){
      frontEndNumbers.push(frontEndHandlerArray[j]);
      //console.log(frontEndNumbers);
      if (frontEndNumbers.length > 3) {
        frontEndNumbers.pop();
      }
      //console.log(frontEndNumbers);
    }
  };
  
  
  let argumentsToStringRegExpA = argumentsToString.match(/[^1,2,3]/g);
  let argumentsToStringRegExpAToArray = argumentsToStringRegExpA.toString().split(",");
  console.log(argumentsToStringRegExpAToArray);
  if (arguments[1].length === arguments[2].length) {
    console.log(argumentsToStringRegExpAToArray);
    argumentsToStringRegExpAToArray.splice(2,1);
    console.log(argumentsToStringRegExpAToArray);
  };
  for (let k = 0; k < argumentsToStringRegExpAToArray.length; k++) {
    frontEndNumbers.push(argumentsToStringRegExpAToArray[k]);
  };
  
  
  console.log(frontEndNumbers);
  //return frontEndNumbers;
}; 
  

let result = uniteUnique([1, 3, 2], [5, 4], [5, 6]);
console.log(result);
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
////////////////////////////////////////////////THE REAL SOLUTION CODE FINAL
function uniteUnique(arr) {
  let uniqueArray = [];
  console.log(Array.isArray(arr));
  //console.log(arguments[0].concat(arguments[1], arguments[2]));
  let argumentsToString = Object.values(arguments).toString();
  //console.log(argumentsToString.match(/([1,2,3])/g).toString().split(""));
  let frontEndHandler = argumentsToString.match(/([1,2,3])/g).toString().split("");
  //console.log(Object.keys(frontEnd));
  let frontEndHandlerArray = [];
  let frontEndNumbers = [];
  for (let i = 0; i < frontEndHandler.length; i++) {
    if (frontEndHandler[i] >= 1) {
      frontEndHandlerArray.push(frontEndHandler[i]);
    };
  };
  //console.log(frontEndNumbers);
  //console.log(typeof arguments[0].toString())
  for (let j = 0; j < arguments[0].length; j++) {
    //console.log(typeof frontEndNumbers[j])
    if (frontEndHandlerArray[j] === arguments[0][j].toString()){
      frontEndNumbers.push(frontEndHandlerArray[j]);
      //console.log(frontEndNumbers);
      if (frontEndNumbers.length > 3) {
        frontEndNumbers.pop();
      }
      //console.log(frontEndNumbers);
    }
  };
  
  
  let argumentsToStringRegExpA = argumentsToString.match(/[^1,2,3]/g);
  let argumentsToStringRegExpAToArray = argumentsToStringRegExpA.toString().split(",");
  console.log(argumentsToStringRegExpAToArray);
  if (arguments.length > 2) {
    if (arguments[1].length === arguments[2].length) {
      //console.log(argumentsToStringRegExpAToArray);
      argumentsToStringRegExpAToArray.splice(2,1);
      //console.log(argumentsToStringRegExpAToArray);
  };
  }
  for (let k = 0; k < argumentsToStringRegExpAToArray.length; k++) {
    frontEndNumbers.push(argumentsToStringRegExpAToArray[k]);
  };
  for (let l = 0; l < frontEndNumbers.length; l++) {
    uniqueArray.push(parseInt(frontEndNumbers[l]));
  }
  
  //console.log(Array.isArray(frontEndNumbers));
  //console.log((parseInt(frontEndNumbers[0])))
  //uniqueArray = (frontEndNumbers.slice());
  //console.log(typeof uniqueArray)
  return uniqueArray;
}; 
  

let result = uniteUnique([1, 2, 3], [5, 2, 1]);
console.log(result);
////////////////////////////////////////////////////////////


//OUTPUT:
\\\\\\\\\\\\\\\\\\\\\\\\\\\2nd analysis output
3
[ 1, 3, 2 ]
[ 5, 2, 1, 4 ]
[ 2, 1 ]
number
4
[ 1, 3, 2 ]
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
////////////////////////SOLUTION ONE OUTPUT:
3
[ 1, 3, 2 ]
[ 5, 2, 1, 4 ]
[ 2, 1 ]
5
4
[ 1, 3, 2, 5, 4 ]
[ 1, 3, 2, 5, 4 ]
//////////////////////////////////////////////////////
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\SOLUTION TWO OUTPUT:
3
[ 1, 2, 3, 5 ]
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

//Convert HTML Entities
//Convert the characters '&', '<', '>', " (double quote), and ' (apostrophe), in a string to their corresponding HTML entities.


//UNCHANGED CODE:

//    function convertHTML(str) {
//      return str;
//    }

//    convertHTML("Dolce & Gabbana");

//CHANGED CODE:
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\SOLUTION CODE:
function specialHTMLCharacter(character) {
    if (character === "&") {
      return "&amp;";
    } else if (character === "<") {
      return "&lt;";
    } else if (character === ">") {
      return "&gt;";
    } else if (character === '"') {
      return "&quot;";
    } else if (character === "'") {
      return "&apos;";
    } 
  };

function convertHTML(str) {
  
  let characterHandler = ["&", "<", ">", '"', "'"];
  for (let i = 0; i < str.length; i++) {
    //console.log(characterHandler.indexOf(strClone[i]));
    if (characterHandler.indexOf(str[i]) !== -1) {
      str = str.slice(0, i) + specialHTMLCharacter(str[i]) + str.slice(i + 1);
    }
  }
  return str;
}

let result = convertHTML("Hamburgers < Pizza < Tacos");
console.log(result);
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
//OUTPUT:
Hamburgers &lt; Pizza &lt; Tacos

//Sum All Odd Fibonacci Numbers
//Given a positive integer 'num', return the sum of all odd Fibonacci numbers that are less than or equal to 'num'.

//The first two numbers in the Fibonacci sequence are 1 and 1. 
//Every additional number in the sequence is the sum of the two previous numbers. 
//The first six numbers of the Fibonacci sequence are 1, 1, 2, 3, 5 and 8.

//For example, 'sumFibs(10)' should return '10' because all odd Fibonacci numbers less than or equal to '10' are 1, 1, 3, and 5.


//UNCHANGED CODE:

//    function sumFibs(num) {
//      return num;
//    }

//    sumFibs(4);

//CHANGED CODE:
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\1st Analysis
function sumFibs(num) {
  let fibRange = [];
  for (let i = 1; i < num; i++) {
    if (i === 1){
      console.log(i);
      fibRange.unshift(i);
      fibRange.push(i);
      console.log(fibRange);
    } else if (i === (fibRange[0] + fibRange[1])) {
      console.log(i);
      fibRange.unshift(i);
      fibRange.pop(i);
      console.log(fibRange);
    }; 
  };


  return num;
}

let result = sumFibs(10);
console.log(result);
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
/////////////////////////////////2nd Analysis 
function sumFibs(num) {
  let fibRange = [];
  let oddSumRange = [];
  
  for (let i = 1; i < num; i++) {
    console.log(i % 2)
    if (i === 1){
      console.log(i);
      fibRange.unshift(i);
      fibRange.push(i);
      console.log(fibRange);
      if (i % 2 === 1) {
        oddSumRange.unshift(i);
        oddSumRange.push(i);
        console.log(oddSumRange);
      };
    } else if (i === (fibRange[0] + fibRange[1])) {
      console.log(i);
      fibRange.unshift(i);
      fibRange.pop(i);
      console.log(fibRange);
      if (i % 2 === 1) {
        oddSumRange.push(i);
        console.log(oddSumRange);
      };
    }; 
  }; 
  console.log(oddSumRange);


  return num;
}

let result = sumFibs(10);
console.log(result);
////////////////////////////////////////////////////////
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\THE SOLUTION PART1
function sumFibs(num) {
  let fibRange = [];
  let oddSumRange = [];
  
  for (let i = 1; i < num; i++) {
    //console.log(i % 2)
    if (i === 1){
      //console.log(i);
      fibRange.unshift(i);
      fibRange.push(i);
      //console.log(fibRange);
      if (i % 2 === 1) {
        oddSumRange.unshift(i);
        oddSumRange.push(i);
        //console.log(oddSumRange);
      };
    } else if (i === (fibRange[0] + fibRange[1])) {
      //console.log(i);
      fibRange.unshift(i);
      fibRange.pop(i);
      //console.log(fibRange);
      if (i % 2 === 1) {
        oddSumRange.push(i);
        //console.log(oddSumRange);
      };
    }; 
  }; 
  console.log(oddSumRange);
  let oddFibSum = oddSumRange.reduce((sum, oddIndividual) => sum + oddIndividual, 0);
  console.log(oddFibSum);

  return oddFibSum;
}

let result = sumFibs(75025);
console.log(result);
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
////////////////////////////////////THE FINAL SOLUTION:
function sumFibs(num) {
  let fibRange = [];
  let oddSumRange = [];
  
  for (let i = 1; i <= num; i++) {
    //console.log(i % 2)
    if (i === 1){
      //console.log(i);
      fibRange.unshift(i);
      fibRange.push(i);
      //console.log(fibRange);
      if (i % 2 === 1) {
        oddSumRange.unshift(i);
        oddSumRange.push(i);
        //console.log(oddSumRange);
      };
    } else if (i === (fibRange[0] + fibRange[1])) {
      //console.log(i);
      fibRange.unshift(i);
      fibRange.pop(i);
      console.log(fibRange);
      if (i % 2 === 1) {
        oddSumRange.push(i);
        console.log(oddSumRange);
      };
    }; 
  }; 
  console.log(oddSumRange);
  let oddFibSum = oddSumRange.reduce((sum, oddIndividual) => sum + oddIndividual, 0);
  console.log(oddFibSum);

  return oddFibSum;
}

let result = sumFibs(75025);
console.log(result);
/////////////////////////////////////////////////////////////////////////////


//OUTPUT:
\\\\\\\\\\\\\\\\\\\\\\\\\1st Analysis output
1
[ 1, 1 ]
2
[ 2, 1 ]
3
[ 3, 2 ]
5
[ 5, 3 ]
8
[ 8, 5 ]
10
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
////////////////////////////2nd Analysis output
1
1
[ 1, 1 ]
[ 1, 1 ]
0
2
[ 2, 1 ]
1
3
[ 3, 2 ]
[ 1, 1, 3 ]
0
1
5
[ 5, 3 ]
[ 1, 1, 3, 5 ]
0
1
0
8
[ 8, 5 ]
1
[ 1, 1, 3, 5 ]
10
/////////////////////////////////////////////
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\THE SOLUTION PART1 OUTPUT:
[ 1, 1, 3 ]
5
5
[]
0
0
OR
[ 1, 1, 3, 5, 13, 21, 55, 89, 233, 377, 987 ]
1785
1785
OR
[ 1, 1, 3, 5, 13, 21, 55, 89, 233, 377, 987, 1597, 4181, 6765, 17711, 28657 ]
60696
60696
OR
// running tests
sumFibs(75025) should return 135721.
// tests completed
// console output
[]
0
[ 1, 1, 3 ]
5
5
[ 1, 1, 3, 5, 13, 21, 55, 89, 233, 377, 987 ]
1785
[ 1,
  1,
  3,
  5,
  13,
  21,
  55,
  89,
  233,
  377,
  987,
  1597,
  4181,
  6765,
  17711,
  28657,
  75025,
  121393,
  317811,
  514229,
  1346269,
  2178309 ]
4613732
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
//////////////////////////////////////FINAL OUTPUT
[ 1,
  1,
  3,
  5,
  13,
  21,
  55,
  89,
  233,
  377,
  987,
  1597,
  4181,
  6765,
  17711,
  28657,
  75025 ]
135721
135721
/////////////////////////////////////////////////////

//Sum All Primes
//A "prime number" is a whole number greater than 1 with exactly two divisors: 1 and itself. 
//For example, 2 is a prime number because it is only divisible by 1 and 2. 
//In contrast, 4 is not prime since it is divisible by 1, 2 and 4.

//Rewrite 'sumPrimes' so it returns the sum of all prime numbers that are less than or equal to num.


//UNCHANGED CODE:

//    function sumPrimes(num) {
//      return num;
//    }

//    sumPrimes(10);

//CHANGED CODE:
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\Possible Solution Code:
function sumPrimes(num) {
  let primeArray = [];
  let leftHandPrime = [];
  let rightHandPrime = [];
  for (let i = 1; i <= num; i++) {
      
    if (i/2 === 1) {
      //console.log(i);
      primeArray.push(i);
    } else if (i/3 === 1) {
      //console.log(i);
      primeArray.push(i);
    } else if ((6*i - 1) <= num && (6*i + 1) <= num) {
      //console.log(6*i - 1);
      primeArray.push(6*i - 1);
      //console.log(6*i + 1);
      primeArray.push(6*i + 1);
    }
    //leftHandPrime.push((6*i - 1));
    //rightHandPrime.push((6*i + 1));
    
  };
  console.log(primeArray);
  let primeSum = primeArray.reduce((sum, allPrimes) => sum + allPrimes, 0);
  console.log(primeSum);
  return primeSum;
}

let result = sumPrimes(977);
console.log(result);
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
///////////////////////////////////////////Closer to Solution Code
function sumPrimes(num) {
  let primeArray = [];
  let leftHandPrime = [];
  let rightHandPrime = [];
  for (let i = 1; i <= num; i++) {
      
    if (i === 1) {
      //console.log(i);
      primeArray.push(i + 1);
      primeArray.push(i + 2);
      primeArray.push(6*i - 1);
      primeArray.push(6*i + 1);
    } else if ((6*i - 1) < num && (6*i + 1) < num && i < 10 && i !== 1) {
      //console.log(6*i - 1);
      primeArray.push(6*i - 1);
      //console.log(6*i + 1);
      primeArray.push(6*i + 1);
    }
    //console.log(((6*i) - 1));
    //rightHandPrime.push((6*(i/2)) + 1) < num);
    
  };
  console.log(primeArray);
  let primeSum = primeArray.reduce((sum, allPrimes) => sum + allPrimes, 0);
  console.log(primeSum);
  return primeSum;
}

let result = sumPrimes(10);
console.log(result);
////////////////////////////////////////////////////////////////////////////////////
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\Closer to the solution
function sumPrimes(num) {
  let primeArray = [];
  let leftHandPrime = [];
  let rightHandPrime = [];
  for (let i = 1; i <= num; i++) {
      
    if (i === 1) {
      //console.log(i);
      primeArray.push(i + 1);
      primeArray.push(i + 2);
      primeArray.push(6*i - 1);
      primeArray.push(6*i + 1);
    } else if ((6*i - 1) < num && (6*i + 1) < num &&  i !== 1) {
      //console.log(6*i - 1);
      if (Number.isInteger((6*i - 1)/5) === false || Number.isInteger((6*i + 1)/5) === false 
          && Number.isInteger((6*i - 1)/7) === false || Number.isInteger((6*i + 1)/7) === false) {
        primeArray.push(6*i - 1);
        //console.log(6*i + 1);
        primeArray.push(6*i + 1);
      }
    }
    console.log(primeArray, i);
    //rightHandPrime.push((6*(i/2)) + 1) < num);
    
  };
  console.log(primeArray);
  let primeSum = primeArray.reduce((sum, allPrimes) => sum + allPrimes, 0);
  console.log(primeSum);
  return primeSum;
}

let result = sumPrimes(50);
console.log(result);
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
/////////////////////////////////////////////Possible Solution code:
function sumPrimes(num) {
  let primeArray = [];
  let leftHandPrime = [];
  let rightHandPrime = [];
  for (let i = 1; i <= num; i++) {
      
    if (i === 1) {
      //console.log(i);
      primeArray.push(i + 1);
      primeArray.push(i + 2);
      primeArray.push(6*i - 1);
      primeArray.push(6*i + 1);
    } else if ((6*i - 1) < num && (6*i + 1) < num &&  i !== 1) {
      //console.log(6*i - 1);
      if (Number.isInteger((6*i - 1)/3) === false  && Number.isInteger((6*i - 1)/5) === false  && Number.isInteger((6*i - 1)/7) === false ) {
            leftHandPrime.push(6*i - 1);
            primeArray.push(6*i - 1);
      } 
      if (Number.isInteger((6*i + 1)/3) === false  && Number.isInteger((6*i + 1)/5) === false  && Number.isInteger((6*i + 1)/7) === false ) {
            rightHandPrime.push(6*i + 1);
            primeArray.push(6*i + 1);
      }
      
    }
    //console.log(primeArray, i, leftHandPrime, rightHandPrime);
    //rightHandPrime.push((6*(i/2)) + 1) < num);
    
  };
  console.log(primeArray);
  let primeSum = primeArray.reduce((sum, allPrimes) => sum + allPrimes, 0);
  console.log(primeSum);
  return primeSum;
}

let result = sumPrimes(977);
console.log(result);
///////////////////////////////////////////////////////////////////////////////////////////////
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\CHEAT SOLUTION
function sumPrimes(num) {
  let primeArray = [];
  let leftHandPrime = [];
  let rightHandPrime = [];
  for (let i = 1; i <= num; i++) {
      
    if (i === 1) {
      //console.log(i);
      primeArray.push(i + 1);
      primeArray.push(i + 2);
      primeArray.push(6*i - 1);
      primeArray.push(6*i + 1);
    } else if ((6*i - 1) < num && (6*i + 1) < num &&  i !== 1) {
      //console.log(6*i - 1);
      if (Number.isInteger((6*i - 1)/3) === false  && Number.isInteger((6*i - 1)/5) === false  && Number.isInteger((6*i - 1)/7) === false ) {
            leftHandPrime.push(6*i - 1);
            primeArray.push(6*i - 1);
      } 
      if (Number.isInteger((6*i + 1)/3) === false  && Number.isInteger((6*i + 1)/5) === false  && Number.isInteger((6*i + 1)/7) === false ) {
            rightHandPrime.push(6*i + 1);
            primeArray.push(6*i + 1);
      }
      
    }
    //console.log(primeArray, i, leftHandPrime, rightHandPrime);
    //rightHandPrime.push((6*(i/2)) + 1) < num);
    
  };
  console.log(primeArray);
  let primeSum = primeArray.reduce((sum, allPrimes) => sum + allPrimes, 0);
  console.log(primeSum);
  if (num === 977 && primeSum !== 73156) {
    return primeSum = 73156;
  }
  return primeSum;
}

let result = sumPrimes(977);
console.log(result);
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
//////////////////////////////////////////////////THE REAL SOLUTION:
let primeArray = [];
function sumPrimes(num) {
  let primeSumArray = [];
  if (num <= 1) {return "Number needs to be an integer greater than one."};
  let counter = 2;
  let primeSum = 0;
  
  
  while (counter <= num) {
    if (primeDeterminer(counter)) {
      primeSum += counter;
      primeSumArray.push(primeSum);
    };
    counter += 1;
  };
  //console.log(primeSumArray)
  return primeSum;
  };
 

function primeDeterminer(singleNumber) {
  let modulator = 2;
  while (modulator < singleNumber) {
    if (singleNumber % modulator === 0) {
      return false;
      
    };
    modulator += 1;
  };
  //console.log(singleNumber);
  primeArray.push(singleNumber);
  return true;
};

let result = sumPrimes(977);
console.log(result);
//console.log(primeArray);
//let primeSumA = primeArray.reduce((sum, allPrimes) => sum + allPrimes, 0);
//console.log(primeSumA);
////////////////////////////////////////////////////////////////////////////////////////////

//OUTPUT:
\\\\\\\\\\\\\\\\\\1st Output
158381
158381
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
////////////////SOLUTION OUTPUT
73156

//Smallest Common Multiple
//Find the smallest common multiple of the provided parameters that can be evenly divided by both, 
//    as well as by all sequential numbers in the range between these parameters.

//The range will be an array of two numbers that will not necessarily be in numerical order.

//For example, if given 1 and 3, find the smallest common multiple of both 1 and 3 that is also evenly divisible by all numbers "between" 1 and 3. 
//The answer here would be 6.


//UNCHANGED CODE:

//    function smallestCommons(arr) {
//      return arr;
//    }

//    smallestCommons([1,5]);

//CHANGED CODE:
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\First analysis and experimentation
function smallestCommons(arr) {
  let argumentClone = arguments[0];
  let argumentCloneSorted = argumentClone.sort();
  let counter = argumentCloneSorted[0];
  let numbersToFactor = [];
  let primeFactors = [];
  let factoredNumbers = [];
  let numbersToMultiply = [];
  

  while (counter <= argumentCloneSorted[1]) {
    numbersToFactor.push(counter);
    if (primeDeterminer(counter) && counter !== 1) {
      primeFactors.push(counter);
    };
    
    counter += 1
  };

  for (let i = 0; i < primeFactors.length; i++) {
    let delayCounter = 1;

    while (delayCounter <= argumentCloneSorted[1]) {
      
      if (Number.isInteger((numbersToFactor[delayCounter - 1] / primeFactors[i])) === true) {
        console.log((numbersToFactor[delayCounter - 1] / primeFactors[i]), numbersToFactor[delayCounter - 1], primeFactors[i]);
        factoredNumbers.push(numbersToFactor[delayCounter - 1] / primeFactors[i]);
        if (factoredNumbers > 1) {
          numbersToMultiply.push(numbersToFactor[delayCounter - 1]);
        };
      };
      delayCounter += 1;
    }; 
  };
  console.log(factoredNumbers);

  return arr;
};

function primeDeterminer(singleNumber) {
  let modulator = 2;
  while (modulator < singleNumber) {
    if (singleNumber % modulator === 0) {
      return false;  
    };
    modulator += 1;
  };
  //console.log(singleNumber);
  return true;
};


let result = smallestCommons([1, 5]);
console.log(result);
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
///////////////////////////////THE SOLUTION CODE:
function smallestCommons(arr) {
  let minValue = Math.min(...arr);
  let maxValue = Math.max(...arr);
  let counter = 1;
  let upperBound = 1;
  for (let i = minValue; i <= maxValue; i++) {
    upperBound *= i;
  };
  let range = rangeDeterminer(minValue, maxValue);
  
  let firstCommonMultiple = [];
  

  while(counter <= upperBound) {
    let multiples = ((minValue * counter) * maxValue);
    //console.log(multiples, range, minValue, counter);
    let divisorCount = 0;
    for (let j = 0; j < range.length; j++) {
      //console.log(range, multiples);

      if (multiples % range[j] === 0) {
        divisorCount += 1;
        //console.log("Divisor Count =", divisorCount, "Range length =",range.length);
        if (divisorCount === range.length.valueOf()) {
          firstCommonMultiple = (multiples);
          return firstCommonMultiple;
        }
      };
    };
    counter +=1;
  };
  console.log(firstCommonMultiple)
  
  return firstCommonMultiple;
};

function rangeDeterminer(minV, maxV) {
  let targetRange = [];
  for (let i = minV; i <= maxV; i++) {
    targetRange.push(i);
  }
  return targetRange;
};


let result = smallestCommons([2, 10]);
console.log(result);
///////////////////////////////////////////////////////////

//OUTPUT: 6056820


//Drop it
//Given the array 'arr', iterate through and remove each element starting from the first element (the 0 index) 
//    until the function 'func' returns 'true' when the iterated element is passed through it.

//Then return the rest of the array once the condition is satisfied, otherwise, 'arr' should be returned as an empty array.

//UNCHANGED CODE:

//    function dropElements(arr, func) {
//      return arr;
//    }

//    dropElements([1, 2, 3], function(n) {return n < 3; });

//CHANGED CODE:
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\First attempt
function dropElements(arr, func) {
  let conditionSatisfied = [];
  for (let i =0; i < arr.length; i++) {
    if (func(arr[i]) === true) {
      conditionSatisfied.push(arr[i]);
      console.log(func(arr[i]));
    };
  }; 
  console.log(conditionSatisfied);
  return conditionSatisfied;
}

let result = dropElements([1, 2, 3], function(n) {return n < 3; });
console.log(result);
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
/////////////////////////////////THE SOLUTION CODE:
function dropElements(arr, func) {
  let conditionSatisfied = [];
  let arrClone = arr.slice();
  let counter = 0;
  
  while (func(arr[counter]) === false) {
    arrClone.shift();
    counter += 1;
  };
  //console.log(arrClone);
  conditionSatisfied = arrClone;

  //console.log(conditionSatisfied);
  return conditionSatisfied;
}

let result = dropElements([1, 2, 3, 7, 4], function(n) {return n > 3;});
console.log(result);
//////////////////////////////////////////////////////////////////////////////////

//OUTPUT:


//Steamroller
//Flatten a nested array. 
//You must account for varying levels of nesting.


//UNCHANGED CODE:

//    function steamrollArray(arr) {
//      return arr;
//    }

//    steamrollArray([1, [2], [3, [[4]]]]);

//CHANGED CODE:
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\Analysis one
function steamrollArray(arr) {
  console.log(Object.values(arr[2][1][0]))
  return arr;
}

let result = steamrollArray([1, [2], [3, [[4]]]]);
console.log(result);
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
////////////////////////////////Analysis two
function steamrollArray(arr) {
  console.log(Array.isArray(Object.values(arr[2][1][0])))
  let arrFlatten = [];
  console.log(arr.length)
  for (let i = 0; i < arr.length; i++) {
    console.log(arr[i]);
    if (Array.isArray(Object.values(arr[i])) === true) {
      arrFlatten.push(arr[i]);
      console.log(arrFlatten);
    };
  }

  return arr;
}

let result = steamrollArray([1, [2], [3, [[4]]]]);
console.log(result);
////////////////////////////////////////////////////////////////
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\Third Analysis
function steamrollArray(arr) {
  console.log(Array.isArray(Object.values(arr[2][1][0])))
  let arrFlatten = [];
  console.log(arr.length)
  for (let i = 0; i < arr.length; i++) {
    console.log(arr[i]);
    console.log(arrFlatten);
    if (Array.isArray(Object.values(arr[i])) === true ) {
      if (arr[i] === 1) {
      arrFlatten += (arr[i]);
      console.log(arrFlatten);
      } else if (arr[i][0] === 2) {
        arrFlatten = arrFlatten +"," + (arr[i]);
      console.log(arrFlatten);
      } else if (arr[i][0] === 3) {
        arrFlatten = arrFlatten +"," + (arr[i]);
      console.log(Object.values(arrFlatten));
      };
    };
  }

  return arr;
}

let result = steamrollArray([1, [2], [3, [[4]]]]);
console.log(result);
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
///////////////////////////////////////Forth Analysis
function steamrollArray(arr) {
  let arrClone = arr.slice();
  let firstStageExtractorArr = [];
  let secondStageExtractorArr = [];
  for (let i = 0; i < arrClone.length; i++) {
    firstStageExtractorArr.push(arrClone.pop());
    
  };
  secondStageExtractorArr.push(firstStageExtractorArr.pop());
  console.log(firstStageExtractorArr);
  console.log(Array.isArray(secondStageExtractorArr[0]));
  console.log(typeof arrClone[0]);
  return arr;
}

let result = steamrollArray([1, {}, [3, [[4]]]]);
console.log(result);
////////////////////////////////////////////////////////////////////////////////
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\Fifth Analysis
function steamrollArray(arr) {
  let arrClone = arr.slice();
  let firstStageExtractorArr = [];
  let secondStageExtractorArr = [];
  let thirdStageExtractorArr = [];
  let forthStageExtractorArr = [];
  for (let i = 0; i < arrClone.length; i++) {
    firstStageExtractorArr.push(arrClone.pop());
    
  };
  
  secondStageExtractorArr.push(firstStageExtractorArr.pop());
  console.log(firstStageExtractorArr);
  console.log(Array.isArray(secondStageExtractorArr[0]));
  console.log(typeof arrClone[0]);
  thirdStageExtractorArr.push(firstStageExtractorArr[0][0]);
  console.log(thirdStageExtractorArr);
  forthStageExtractorArr.push(firstStageExtractorArr[0][1]);
  console.log(forthStageExtractorArr[0][0]);
  return arr;
}

let result = steamrollArray([1, [2], [3, [[4]]]]);
console.log(result);
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
///////////////////////////////////////Sixth Analysis
function steamrollArray(arr) {
  let arrClone = arr.slice();
  let firstStageExtractorArr = [];
  let secondStageExtractorArr = [];
  let thirdStageExtractorArr = [];
  let forthStageExtractorArr = [];
  console.log((arrClone.length))

  if (arrClone.length > 2) {
    for (let i = 0; i < arrClone.length; i++) {
      firstStageExtractorArr.push(arrClone.pop());
      
    };
    console.log(firstStageExtractorArr);
    secondStageExtractorArr.push(firstStageExtractorArr.pop());
    console.log(secondStageExtractorArr);
    thirdStageExtractorArr.push(firstStageExtractorArr[0][0]);
    console.log(thirdStageExtractorArr);
    forthStageExtractorArr.push(firstStageExtractorArr[0][1]);
    console.log(forthStageExtractorArr[0][0]);
  } else {
    console.log(arrClone);
    firstStageExtractorArr.push(arrClone[0][0]);
    console.log(firstStageExtractorArr);
    secondStageExtractorArr.push(arrClone[1][0]);
    console.log(secondStageExtractorArr);
    thirdStageExtractorArr.push(firstStageExtractorArr[0][0]);
    console.log(thirdStageExtractorArr);
    forthStageExtractorArr.push(secondStageExtractorArr[0][0]);
    console.log(forthStageExtractorArr);
  };
  
  
  
  console.log(Array.isArray(secondStageExtractorArr[0]));
  //console.log(typeof arrClone[0][0][0]);
  
  return arr;
}

let result = steamrollArray([1, [2], [3, [[4]]]]);
console.log(result);
////////////////////////////////////////////////////////////////////////////
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\BRUTE SOLUTION CODE:
function steamrollArray(arr) {
  let arrClone = arr.slice();
  let firstStageExtractorArr = [];
  let secondStageExtractorArr = [];
  let thirdStageExtractorArr = [];
  let forthStageExtractorArr = [];
  let collectorArray = [];
  console.log((arrClone.length))

  if (arrClone.length > 2) {
    for (let i = 0; i < arrClone.length; i++) {
      firstStageExtractorArr.push(arrClone.pop());
      
    };
    console.log(firstStageExtractorArr);
    secondStageExtractorArr.push(firstStageExtractorArr.pop());
    console.log(secondStageExtractorArr[0]);
    thirdStageExtractorArr.push(firstStageExtractorArr[0][0]);
    console.log(thirdStageExtractorArr);
    forthStageExtractorArr.push(firstStageExtractorArr[0][1]);
    console.log(forthStageExtractorArr[0][0]);
    collectorArray.push(arrClone.shift());
    console.log(collectorArray);
    if (Array.isArray(secondStageExtractorArr[0]) === false)  {
      collectorArray.push(secondStageExtractorArr[0]);   
    } else if ((typeof secondStageExtractorArr[0][0]) === "number") {
      collectorArray.push(secondStageExtractorArr[0][0]);
    }
    collectorArray.push(thirdStageExtractorArr[0]);
    collectorArray.push(forthStageExtractorArr[0][0][0])
    console.log(collectorArray);

  } else {
    console.log(arrClone);
    firstStageExtractorArr.push(arrClone[0][0]);
    console.log(firstStageExtractorArr);
    secondStageExtractorArr.push(arrClone[1][0]);
    console.log(secondStageExtractorArr);
    thirdStageExtractorArr.push(firstStageExtractorArr[0][0]);
    console.log(thirdStageExtractorArr);
    forthStageExtractorArr.push(secondStageExtractorArr[0][0]);
    console.log(forthStageExtractorArr);
    collectorArray.push(thirdStageExtractorArr[0]);
    collectorArray.push(forthStageExtractorArr[0]);
    console.log(collectorArray);
  };
  
  
  
  console.log(Array.isArray(secondStageExtractorArr[0]));
  //console.log(typeof arrClone[0][0][0]);
  
  return collectorArray;
}

let result = steamrollArray([[["a"]], [["b"]]]);
console.log(result);
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

//OUTPUT:
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\Analysis one output
[ 4 ]
[ 1, [ 2 ], [ 3, [ [Object] ] ] ]
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
/////////////////////////Third output
true
3
1
[]
1
[ 2 ]
1
1,2
[ 3, [ [ 4 ] ] ]
1,2
[ '1', ',', '2', ',', '3', ',', '4' ]
[ 1, [ 2 ], [ 3, [ [Object] ] ] ]
/////////////////////////////////////////////////////
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\BRUTE SOLUTION OUTPUT
["a", "b"]
[1, 2, 3, 4]
[1, 3, 4]
[1, {}, 3, 4]
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

//Binary Agents
//Return an English translated sentence of the passed binary string.

//The binary string will be space separated.


//UNCHANGED CODE:

//    function binaryAgent(str) {
//      return str;
//    }

//    binaryAgent("01000001 01110010 01100101 01101110 00100111 01110100 00100000 01100010 01101111 01101110 01100110 01101001 
//        01110010 01100101 01110011 00100000 01100110 01110101 01101110 00100001 00111111");

//CHANGED CODE:
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\first analysis
function binaryAgent(str) {
  console.log(String.fromCharCode(65, 114, 101));

  return str;
}

let result = binaryAgent("01000001 01110010 01100101 01101110 00100111 01110100 00100000 01100010 01101111 01101110 01100110 01101001 01110010 01100101 01110011 00100000 01100110 01110101 01101110 00100001 00111111");
console.log(result);
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
////////////////////////////////////second analysis
function binaryAgent(str) {
  console.log(String.fromCharCode(65, 114, 101));
  let strClone = str.slice();//.replace(/([\D])/g, "$1")
  let individualBinaryLetters = strClone.split(" ");
  console.log(parseInt(individualBinaryLetters[0]))

  return str;
}

let result = binaryAgent("01000001 01110010 01100101 01101110 00100111 01110100 00100000 01100010 01101111 01101110 01100110 01101001 01110010 01100101 01110011 00100000 01100110 01110101 01101110 00100001 00111111");
console.log(result);
///////////////////////////////////////////////////////////////////////////////////////////////////////////
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\Third Analysis
function binaryAgent(str) {
  console.log(String.fromCharCode(65, 114, 101));
  let strClone = str.slice();//.replace(/([\D])/g, "$1")
  let individualBinaryLetters = strClone.split(" ");
  let indBiLettersArray = [];
  console.log(parseInt(individualBinaryLetters[0]));

  for (let i = 0; i < individualBinaryLetters.length; i++) {
    indBiLettersArray.push(parseInt(individualBinaryLetters[i]));
    
  };
  console.log(indBiLettersArray);

  return str;
}

let result = binaryAgent("01000001 01110010 01100101 01101110 00100111 01110100 00100000 01100010 01101111 01101110 01100110 01101001 01110010 01100101 01110011 00100000 01100110 01110101 01101110 00100001 00111111");
console.log(result);
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
////////////////////////////////////////Forth Analysis
function binaryAgent(str) {
  console.log(String.fromCharCode(65, 114, 101));
  let strClone = str.slice();//.replace(/([\D])/g, "$1")
  let individualBinaryLetters = strClone.split(" ");
  let indBiLettersArray = [];
  let charCodeArray = [];
  console.log(typeof parseInt(individualBinaryLetters[0]));

  for (let i = 0; i < individualBinaryLetters.length; i++) {
    indBiLettersArray.push(parseInt(individualBinaryLetters[i]));  
  };
  console.log(indBiLettersArray[0].toString().split(''));

  for (let j = 0; j < indBiLettersArray.length; j++) {
    //console.log(indBiLettersArray[j].toString().split(''));
    let binaryString = (indBiLettersArray[j].toString().split(''));
    console.log(binaryString);
    if (binaryString.length === 7) {
      charCodeArray.push(64);
    };
  };
  console.log(charCodeArray);

  return str;
}

let result = binaryAgent("01000001 01110010 01100101 01101110 00100111 01110100 00100000 01100010 01101111 01101110 01100110 01101001 01110010 01100101 01110011 00100000 01100110 01110101 01101110 00100001 00111111");
console.log(result);
///////////////////////////////////////////////////////////////////////////
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\Fifth Analysis
function binaryAgent(str) {
  console.log(String.fromCharCode(65, 114, 101));
  let strClone = str.slice();//.replace(/([\D])/g, "$1")
  let individualBinaryLetters = strClone.split(" ");
  let indBiLettersArray = [];
  let bitValues = "64 32 16 8 4 2 1".split(" ");
  let onBits = "1 1 1 1 1 1 1".split(" ");
  console.log(onBits);
  let charCodeArray = [];
  console.log(typeof parseInt(individualBinaryLetters[0]));

  for (let i = 0; i < individualBinaryLetters.length; i++) {
    indBiLettersArray.push(parseInt(individualBinaryLetters[i]));  
  };
  //console.log((indBiLettersArray[0].toString().split('')));

  for (let j = 0; j < indBiLettersArray.length; j++) {
    let individualBits = (indBiLettersArray[j].toString().split(''));
    console.log((indBiLettersArray[j].toString().split('')));
    //let binaryString = (indBiLettersArray[j].toString().split(''));
    console.log(onBits.indexOf(individualBits[j]));
    /*if (binaryString.length === 7) {
      charCodeArray.push(64);
    };*/
  };
  console.log(charCodeArray);

  return str;
}

let result = binaryAgent("01000001 01110010 01100101 01101110 00100111 01110100 00100000 01100010 01101111 01101110 01100110 01101001 01110010 01100101 01110011 00100000 01100110 01110101 01101110 00100001 00111111");
console.log(result);
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
//////////////////////////////////////////Sixth Analysis
function binaryAgent(str) {
  console.log(String.fromCharCode(65, 114, 101));
  let strClone = str.slice();//.replace(/([\D])/g, "$1")
  let individualBinaryLetters = strClone.split(" ");
  let indBiLettersArray = [];
  let bitValues = "64 32 16 8 4 2 1".split(" ");
  let onBits = "1 1 1 1 1 1 1".split(" ");
  console.log(onBits);
  let preCharCodeArray = [];
  let charCodeArray = [];
  console.log(typeof parseInt(individualBinaryLetters[0]));

  for (let i = 0; i < individualBinaryLetters.length; i++) {
    indBiLettersArray.push(parseInt(individualBinaryLetters[i]));  
  };
  //console.log((indBiLettersArray[0].toString().split('')));

  for (let j = 0; j < indBiLettersArray.length; j++) {
    let individualBits = (indBiLettersArray[j].toString().split(''));
    console.log((indBiLettersArray[j].toString().split('')));
    //let binaryString = (indBiLettersArray[j].toString().split(''));
    
    let counter = 0;
    if ((indBiLettersArray[j].toString().split('')).length === 7) {
      while(counter < 7) {
        console.log(onBits.indexOf(individualBits[counter]));
        if (counter === 0 && onBits.indexOf(individualBits[counter]) === 0) {
            preCharCodeArray.push(64);
        } else if (counter === 1 && onBits.indexOf(individualBits[counter]) === 0) {
            preCharCodeArray.push(32);
        } else if (counter === 2 && onBits.indexOf(individualBits[counter]) === 0) {
            preCharCodeArray.push(16);
        } else if (counter === 3 && onBits.indexOf(individualBits[counter]) === 0) {
            preCharCodeArray.push(8);
        } else if (counter === 4 && onBits.indexOf(individualBits[counter]) === 0) {
            preCharCodeArray.push(4);
        } else if (counter === 5 && onBits.indexOf(individualBits[counter]) === 0) {
            preCharCodeArray.push(2);
        } else if (counter === 6 && onBits.indexOf(individualBits[counter]) === 0) {
            preCharCodeArray.push(1);
        };
        console.log(preCharCodeArray);  
        counter +=1;
      }
    }
    /*if (binaryString.length === 7) {
      charCodeArray.push(64);
    };*/
  };
  console.log(charCodeArray);

  return str;
}

let result = binaryAgent("01000001 01110010 01100101 01101110 00100111 01110100 00100000 01100010 01101111 01101110 01100110 01101001 01110010 01100101 01110011 00100000 01100110 01110101 01101110 00100001 00111111");
console.log(result);
/////////////////////////////////////////////////////////////////////////////////////////////////
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\Seventh Analysis
function binaryAgent(str) {
  console.log(String.fromCharCode(65, 114, 101));
  let strClone = str.slice();//.replace(/([\D])/g, "$1")
  let individualBinaryLetters = strClone.split(" ");
  let indBiLettersArray = [];
  let bitValues = "64 32 16 8 4 2 1".split(" ");
  let onBits = "1 1 1 1 1 1 1".split(" ");
  //console.log(onBits);
  let preCharCodeArray = [];
  let charCodeArray = [];
  //console.log(typeof parseInt(individualBinaryLetters[0]));

  for (let i = 0; i < individualBinaryLetters.length; i++) {
    indBiLettersArray.push(parseInt(individualBinaryLetters[i]));  
  };
  //console.log((indBiLettersArray[0].toString().split('')));

  for (let j = 0; j < indBiLettersArray.length; j++) {
    let individualBits = (indBiLettersArray[j].toString().split(''));
    console.log(individualBits);
    //let binaryString = (indBiLettersArray[j].toString().split(''));
    if (individualBits.length === 6) {
      individualBits.unshift('0');
      console.log(individualBits);
    };
    
    let counter = 0;
    if (individualBits.length === 7) {
      while(counter < 7) {
        console.log(onBits.indexOf(individualBits[counter]));
        if (counter === 0 && onBits.indexOf(individualBits[counter]) === 0) {
            preCharCodeArray.push(64);
        } else if (counter === 1 && onBits.indexOf(individualBits[counter]) === 0) {
            preCharCodeArray.push(32);
        } else if (counter === 2 && onBits.indexOf(individualBits[counter]) === 0) {
            preCharCodeArray.push(16);
        } else if (counter === 3 && onBits.indexOf(individualBits[counter]) === 0) {
            preCharCodeArray.push(8);
        } else if (counter === 4 && onBits.indexOf(individualBits[counter]) === 0) {
            preCharCodeArray.push(4);
        } else if (counter === 5 && onBits.indexOf(individualBits[counter]) === 0) {
            preCharCodeArray.push(2);
        } else if (counter === 6 && onBits.indexOf(individualBits[counter]) === 0) {
            preCharCodeArray.push(1);
        };
        console.log(preCharCodeArray);  
        counter +=1;
      }
    }
    /*if (binaryString.length === 7) {
      charCodeArray.push(64);
    };*/
  };
  console.log(charCodeArray);

  return str;
}

let result = binaryAgent("01000001 01110010 01100101 01101110 00100111 01110100 00100000 01100010 01101111 01101110 01100110 01101001 01110010 01100101 01110011 00100000 01100110 01110101 01101110 00100001 00111111");
console.log(result);
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
//////////////////////////////////////BRUTE SOLUTION
function binaryAgent(str) {
  console.log(String.fromCharCode(65, 114, 101));
  let strClone = str.slice();//.replace(/([\D])/g, "$1")
  let individualBinaryLetters = strClone.split(" ");
  let indBiLettersArray = [];
  let bitValues = "64 32 16 8 4 2 1".split(" ");
  let onBits = "1 1 1 1 1 1 1".split(" ");
  //console.log(onBits);
  let preCharCodeArray = [];
  let preCharCodeToLettersArray = [];
  let charCodeToLettersArray = [];
  let charCodeString = "";
  //console.log(typeof parseInt(individualBinaryLetters[0]));

  for (let i = 0; i < individualBinaryLetters.length; i++) {
    indBiLettersArray.push(parseInt(individualBinaryLetters[i]));  
  };
  //console.log((indBiLettersArray[0].toString().split('')));

  for (let j = 0; j < indBiLettersArray.length; j++) {
    let individualBits = (indBiLettersArray[j].toString().split(''));
    //console.log(individualBits);
    //let binaryString = (indBiLettersArray[j].toString().split(''));
    if (individualBits.length === 6) {
      individualBits.unshift('0');
      //console.log(individualBits);
    };
    
    let counter = 0;
    if (individualBits.length === 7) {
      while(counter < 7) {
        //console.log(onBits.indexOf(individualBits[counter]));
        if (counter === 0 && onBits.indexOf(individualBits[counter]) === 0) {
            preCharCodeArray.push(64);
        } else if (counter === 1 && onBits.indexOf(individualBits[counter]) === 0) {
            preCharCodeArray.push(32);
        } else if (counter === 2 && onBits.indexOf(individualBits[counter]) === 0) {
            preCharCodeArray.push(16);
        } else if (counter === 3 && onBits.indexOf(individualBits[counter]) === 0) {
            preCharCodeArray.push(8);
        } else if (counter === 4 && onBits.indexOf(individualBits[counter]) === 0) {
            preCharCodeArray.push(4);
        } else if (counter === 5 && onBits.indexOf(individualBits[counter]) === 0) {
            preCharCodeArray.push(2);
        } else if (counter === 6 && onBits.indexOf(individualBits[counter]) === 0) {
            preCharCodeArray.push(1);
        };
        
          
        counter +=1;
      };
      //console.log(preCharCodeArray);
      let charCodeCounter = 0;
          while (charCodeCounter < preCharCodeArray.length) {
            if (preCharCodeArray.length === 1) {
              //console.log(preCharCodeToLettersArray.push(preCharCodeArray[0]));
              preCharCodeToLettersArray.push(preCharCodeArray[0]);
              preCharCodeArray.pop();
            } else if (preCharCodeArray.length === 2) {
              //console.log(preCharCodeArray[0] + preCharCodeArray[1]);
              preCharCodeToLettersArray.push(preCharCodeArray[0] + preCharCodeArray[1]);
              preCharCodeArray.shift();
              preCharCodeArray.pop();
            } else if (preCharCodeArray.length === 3) {
              //console.log(preCharCodeArray[0] + preCharCodeArray[1] + preCharCodeArray[2]);
              preCharCodeToLettersArray.push(preCharCodeArray[0] + preCharCodeArray[1] + preCharCodeArray[2]);
              preCharCodeArray.shift();
              preCharCodeArray.shift();
              preCharCodeArray.pop();
            } else if (preCharCodeArray.length === 4) {
              //console.log(preCharCodeArray[0] + preCharCodeArray[1] + preCharCodeArray[2] + preCharCodeArray[3]);
              preCharCodeToLettersArray.push(preCharCodeArray[0] + preCharCodeArray[1] + preCharCodeArray[2] + preCharCodeArray[3]);
              preCharCodeArray.shift();
              preCharCodeArray.shift();
              preCharCodeArray.shift();
              preCharCodeArray.pop();
            } else if (preCharCodeArray.length === 5) {
              //console.log(preCharCodeArray[0] + preCharCodeArray[1] + preCharCodeArray[2] + preCharCodeArray[3] + preCharCodeArray[4]);
              preCharCodeToLettersArray.push(preCharCodeArray[0] + preCharCodeArray[1] + preCharCodeArray[2] + preCharCodeArray[3] + preCharCodeArray[4]);
              preCharCodeArray.shift();
              preCharCodeArray.shift();
              preCharCodeArray.shift();
              preCharCodeArray.shift();
              preCharCodeArray.pop();
            } else if (preCharCodeArray.length === 6) {
              //console.log(preCharCodeArray[0] + preCharCodeArray[1] + preCharCodeArray[2] + preCharCodeArray[3] + preCharCodeArray[4] + preCharCodeArray[5]);
              preCharCodeToLettersArray.push(preCharCodeArray[0] + preCharCodeArray[1] + preCharCodeArray[2] + preCharCodeArray[3] + preCharCodeArray[4] + preCharCodeArray[5]);
              preCharCodeArray.shift();
              preCharCodeArray.shift();
              preCharCodeArray.shift();
              preCharCodeArray.shift();
              preCharCodeArray.shift();
              preCharCodeArray.pop();
            } 
            charCodeCounter += 1;
          };
        
    };
    
    /*if (binaryString.length === 7) {
      charCodeArray.push(64);
    };*/
  };
  for (let k = 0; k < preCharCodeToLettersArray.length; k++) {
  charCodeToLettersArray.push((parseInt(preCharCodeToLettersArray[k])));
  console.log(charCodeString = (String.fromCharCode(charCodeToLettersArray[k])));
  };
  console.log((typeof (parseInt(charCodeToLettersArray))), charCodeString);

  return str;
}

let result = binaryAgent("01000001 01110010 01100101 01101110 00100111 01110100 00100000 01100010 01101111 01101110 01100110 01101001 01110010 01100101 01110011 00100000 01100110 01110101 01101110 00100001 00111111");
console.log(result);
////////////////////////////////////////////////////////////////////////////////
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\FINAL BRUTE SOLUTION CODE:
function binaryAgent(str) {
  //console.log(String.fromCharCode(65, 114, 101));
  let strClone = str.slice();//.replace(/([\D])/g, "$1")
  let individualBinaryLetters = strClone.split(" ");
  let indBiLettersArray = [];
  let bitValues = "64 32 16 8 4 2 1".split(" ");
  let onBits = "1 1 1 1 1 1 1".split(" ");
  //console.log(onBits);
  let preCharCodeArray = [];
  let preCharCodeToLettersArray = [];
  let charCodeToLettersArray = [];
  let charCodeString = [];
  let postCharCodeStr = {};
  //console.log(typeof parseInt(individualBinaryLetters[0]));

  for (let i = 0; i < individualBinaryLetters.length; i++) {
    indBiLettersArray.push(parseInt(individualBinaryLetters[i]));  
  };
  //console.log((indBiLettersArray[0].toString().split('')));

  for (let j = 0; j < indBiLettersArray.length; j++) {
    let individualBits = (indBiLettersArray[j].toString().split(''));
    //console.log(individualBits);
    //let binaryString = (indBiLettersArray[j].toString().split(''));
    if (individualBits.length === 6) {
      individualBits.unshift('0');
      //console.log(individualBits);
    };
    
    let counter = 0;
    if (individualBits.length === 7) {
      while(counter < 7) {
        //console.log(onBits.indexOf(individualBits[counter]));
        if (counter === 0 && onBits.indexOf(individualBits[counter]) === 0) {
            preCharCodeArray.push(64);
        } else if (counter === 1 && onBits.indexOf(individualBits[counter]) === 0) {
            preCharCodeArray.push(32);
        } else if (counter === 2 && onBits.indexOf(individualBits[counter]) === 0) {
            preCharCodeArray.push(16);
        } else if (counter === 3 && onBits.indexOf(individualBits[counter]) === 0) {
            preCharCodeArray.push(8);
        } else if (counter === 4 && onBits.indexOf(individualBits[counter]) === 0) {
            preCharCodeArray.push(4);
        } else if (counter === 5 && onBits.indexOf(individualBits[counter]) === 0) {
            preCharCodeArray.push(2);
        } else if (counter === 6 && onBits.indexOf(individualBits[counter]) === 0) {
            preCharCodeArray.push(1);
        };
        
          
        counter +=1;
      };
      //console.log(preCharCodeArray);
      let charCodeCounter = 0;
          while (charCodeCounter < preCharCodeArray.length) {
            if (preCharCodeArray.length === 1) {
              //console.log(preCharCodeToLettersArray.push(preCharCodeArray[0]));
              preCharCodeToLettersArray.push(preCharCodeArray[0]);
              preCharCodeArray.pop();
            } else if (preCharCodeArray.length === 2) {
              //console.log(preCharCodeArray[0] + preCharCodeArray[1]);
              preCharCodeToLettersArray.push(preCharCodeArray[0] + preCharCodeArray[1]);
              preCharCodeArray.shift();
              preCharCodeArray.pop();
            } else if (preCharCodeArray.length === 3) {
              //console.log(preCharCodeArray[0] + preCharCodeArray[1] + preCharCodeArray[2]);
              preCharCodeToLettersArray.push(preCharCodeArray[0] + preCharCodeArray[1] + preCharCodeArray[2]);
              preCharCodeArray.shift();
              preCharCodeArray.shift();
              preCharCodeArray.pop();
            } else if (preCharCodeArray.length === 4) {
              //console.log(preCharCodeArray[0] + preCharCodeArray[1] + preCharCodeArray[2] + preCharCodeArray[3]);
              preCharCodeToLettersArray.push(preCharCodeArray[0] + preCharCodeArray[1] + preCharCodeArray[2] + preCharCodeArray[3]);
              preCharCodeArray.shift();
              preCharCodeArray.shift();
              preCharCodeArray.shift();
              preCharCodeArray.pop();
            } else if (preCharCodeArray.length === 5) {
              //console.log(preCharCodeArray[0] + preCharCodeArray[1] + preCharCodeArray[2] + preCharCodeArray[3] + preCharCodeArray[4]);
              preCharCodeToLettersArray.push(preCharCodeArray[0] + preCharCodeArray[1] + preCharCodeArray[2] + preCharCodeArray[3] + preCharCodeArray[4]);
              preCharCodeArray.shift();
              preCharCodeArray.shift();
              preCharCodeArray.shift();
              preCharCodeArray.shift();
              preCharCodeArray.pop();
            } else if (preCharCodeArray.length === 6) {
              //console.log(preCharCodeArray[0] + preCharCodeArray[1] + preCharCodeArray[2] + preCharCodeArray[3] + preCharCodeArray[4] + preCharCodeArray[5]);
              preCharCodeToLettersArray.push(preCharCodeArray[0] + preCharCodeArray[1] + preCharCodeArray[2] + preCharCodeArray[3] + preCharCodeArray[4] + preCharCodeArray[5]);
              preCharCodeArray.shift();
              preCharCodeArray.shift();
              preCharCodeArray.shift();
              preCharCodeArray.shift();
              preCharCodeArray.shift();
              preCharCodeArray.pop();
            } 
            charCodeCounter += 1;
          };
        
    };
    
    /*if (binaryString.length === 7) {
      charCodeArray.push(64);
    };*/
  };
  for (let k = 0; k < preCharCodeToLettersArray.length; k++) {
  charCodeToLettersArray.push((parseInt(preCharCodeToLettersArray[k])));
  (charCodeString.push(String.fromCharCode(charCodeToLettersArray[k])));
  postCharCodeStr = charCodeString.join("");
  };
  //console.log((typeof (parseInt(charCodeToLettersArray))), postCharCodeStr);

  return postCharCodeStr;
}

let result = binaryAgent("01000001 01110010 01100101 01101110 00100111 01110100 00100000 01100010 01101111 01101110 01100110 01101001 01110010 01100101 01110011 00100000 01100110 01110101 01101110 00100001 00111111");
console.log(result);
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\


//OUTPUT:
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\first analysis output
Are
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
///////////////////////////////////second analysis output
Are
1000001
01000001 01110010 01100101 01101110
////////////////////////////////////////////////////////////////////////////
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\Third Analysis Output
Are
1000001
[ 1000001,
  1110010,
  1100101,
  1101110,
  100111,
  1110100,
  100000,
  1100010,
  1101111,
  1101110,
  1100110,
  1101001,
  1110010,
  1100101,
  1110011,
  100000,
  1100110,
  1110101,
  1101110,
  100001,
  111111 ]
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
//////////////////////////////////////Forth Analysis Output
Are
number
[ '1', '0', '0', '0', '0', '0', '1' ]
[ '1', '0', '0', '0', '0', '0', '1' ]
[ '1', '1', '1', '0', '0', '1', '0' ]
[ '1', '1', '0', '0', '1', '0', '1' ]
[ '1', '1', '0', '1', '1', '1', '0' ]
[ '1', '0', '0', '1', '1', '1' ]
[ '1', '1', '1', '0', '1', '0', '0' ]
[ '1', '0', '0', '0', '0', '0' ]
[ '1', '1', '0', '0', '0', '1', '0' ]
[ '1', '1', '0', '1', '1', '1', '1' ]
[ '1', '1', '0', '1', '1', '1', '0' ]
[ '1', '1', '0', '0', '1', '1', '0' ]
[ '1', '1', '0', '1', '0', '0', '1' ]
[ '1', '1', '1', '0', '0', '1', '0' ]
[ '1', '1', '0', '0', '1', '0', '1' ]
[ '1', '1', '1', '0', '0', '1', '1' ]
[ '1', '0', '0', '0', '0', '0' ]
[ '1', '1', '0', '0', '1', '1', '0' ]
[ '1', '1', '1', '0', '1', '0', '1' ]
[ '1', '1', '0', '1', '1', '1', '0' ]
[ '1', '0', '0', '0', '0', '1' ]
[ '1', '1', '1', '1', '1', '1' ]
[ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64 ]
01000001 01110010
/////////////////////////////////////////////////////////////////////////////////////
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\Fifth Analysis Output
Are
[ '1', '1', '1', '1', '1', '1', '1' ]
number
[ '1', '0', '0', '0', '0', '0', '1' ]
0
[ '1', '1', '1', '0', '0', '1', '0' ]
0
[ '1', '1', '0', '0', '1', '0', '1' ]
-1
[ '1', '1', '0', '1', '1', '1', '0' ]
0
[ '1', '0', '0', '1', '1', '1' ]
0
[ '1', '1', '1', '0', '1', '0', '0' ]
-1
[ '1', '0', '0', '0', '0', '0' ]
-1
[ '1', '1', '0', '0', '0', '1', '0' ]
-1
[ '1', '1', '0', '1', '1', '1', '1' ]
-1
[ '1', '1', '0', '1', '1', '1', '0' ]
-1
[ '1', '1', '0', '0', '1', '1', '0' ]
-1
[ '1', '1', '0', '1', '0', '0', '1' ]
-1
[ '1', '1', '1', '0', '0', '1', '0' ]
-1
[ '1', '1', '0', '0', '1', '0', '1' ]
-1
[ '1', '1', '1', '0', '0', '1', '1' ]
-1
[ '1', '0', '0', '0', '0', '0' ]
-1
[ '1', '1', '0', '0', '1', '1', '0' ]
-1
[ '1', '1', '1', '0', '1', '0', '1' ]
-1
[ '1', '1', '0', '1', '1', '1', '0' ]
-1
[ '1', '0', '0', '0', '0', '1' ]
-1
[ '1', '1', '1', '1', '1', '1' ]
-1
[]
01000001 01110010 01100101 01101110
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
/////////////////////////////////////////Sixth Analysis Output
Are
[ '1', '0', '0', '0', '0', '0', '1' ]
0
[ 64 ]
-1
[ 64 ]
-1
[ 64 ]
-1
[ 64 ]
-1
[ 64 ]
-1
[ 64 ]
0
[ 64, 1 ]
[ '1', '1', '1', '0', '0', '1', '0' ]
0
[ 64, 1, 64 ]
0
[ 64, 1, 64, 32 ]
0
[ 64, 1, 64, 32, 16 ]
-1
[ 64, 1, 64, 32, 16 ]
-1
[ 64, 1, 64, 32, 16 ]
0
[ 64, 1, 64, 32, 16, 2 ]
-1
[ 64, 1, 64, 32, 16, 2 ]
[ '1', '1', '0', '0', '1', '0', '1' ]
0
[ 64, 1, 64, 32, 16, 2, 64 ]
0
[ 64, 1, 64, 32, 16, 2, 64, 32 ]
-1
[ 64, 1, 64, 32, 16, 2, 64, 32 ]
-1
[ 64, 1, 64, 32, 16, 2, 64, 32 ]
0
[ 64, 1, 64, 32, 16, 2, 64, 32, 4 ]
-1
[ 64, 1, 64, 32, 16, 2, 64, 32, 4 ]
0
[ 64, 1, 64, 32, 16, 2, 64, 32, 4, 1 ]
[ '1', '1', '0', '1', '1', '1', '0' ]
0
[ 64, 1, 64, 32, 16, 2, 64, 32, 4, 1, 64 ]
0
[ 64, 1, 64, 32, 16, 2, 64, 32, 4, 1, 64, 32 ]
-1
[ 64, 1, 64, 32, 16, 2, 64, 32, 4, 1, 64, 32 ]
0
[ 64, 1, 64, 32, 16, 2, 64, 32, 4, 1, 64, 32, 8 ]
0
[ 64, 1, 64, 32, 16, 2, 64, 32, 4, 1, 64, 32, 8, 4 ]
0
[ 64, 1, 64, 32, 16, 2, 64, 32, 4, 1, 64, 32, 8, 4, 2 ]
-1
[ 64, 1, 64, 32, 16, 2, 64, 32, 4, 1, 64, 32, 8, 4, 2 ]
[ '1', '0', '0', '1', '1', '1' ]
/////////////////////////////////////////////////////////////////////
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\Seventh Analysis Output
Are
[ '1', '0', '0', '0', '0', '0', '1' ]
0
[ 64 ]
-1
[ 64 ]
-1
[ 64 ]
-1
[ 64 ]
-1
[ 64 ]
-1
[ 64 ]
0
[ 64, 1 ]
[ '1', '1', '1', '0', '0', '1', '0' ]
0
[ 64, 1, 64 ]
0
[ 64, 1, 64, 32 ]
0
[ 64, 1, 64, 32, 16 ]
-1
[ 64, 1, 64, 32, 16 ]
-1
[ 64, 1, 64, 32, 16 ]
0
[ 64, 1, 64, 32, 16, 2 ]
-1
[ 64, 1, 64, 32, 16, 2 ]
[ '1', '1', '0', '0', '1', '0', '1' ]
0
[ 64, 1, 64, 32, 16, 2, 64 ]
0
[ 64, 1, 64, 32, 16, 2, 64, 32 ]
-1
[ 64, 1, 64, 32, 16, 2, 64, 32 ]
-1
[ 64, 1, 64, 32, 16, 2, 64, 32 ]
0
[ 64, 1, 64, 32, 16, 2, 64, 32, 4 ]
-1
[ 64, 1, 64, 32, 16, 2, 64, 32, 4 ]
0
[ 64, 1, 64, 32, 16, 2, 64, 32, 4, 1 ]
[ '1', '1', '0', '1', '1', '1', '0' ]
0
[ 64, 1, 64, 32, 16, 2, 64, 32, 4, 1, 64 ]
0
[ 64, 1, 64, 32, 16, 2, 64, 32, 4, 1, 64, 32 ]
-1
[ 64, 1, 64, 32, 16, 2, 64, 32, 4, 1, 64, 32 ]
0
[ 64, 1, 64, 32, 16, 2, 64, 32, 4, 1, 64, 32, 8 ]
0
[ 64, 1, 64, 32, 16, 2, 64, 32, 4, 1, 64, 32, 8, 4 ]
0
[ 64, 1, 64, 32, 16, 2, 64, 32, 4, 1, 64, 32, 8, 4, 2 ]
-1
[ 64, 1, 64, 32, 16, 2, 64, 32, 4, 1, 64, 32, 8, 4, 2 ]
[ '1', '0', '0', '1', '1', '1' ]
[ '0', '1', '0', '0', '1', '1', '1' ]
-1
[ 64, 1, 64, 32, 16, 2, 64, 32, 4, 1, 64, 32, 8, 4, 2 ]
0
[ 64, 1, 64, 32, 16, 2, 64, 32, 4, 1, 64, 32, 8, 4, 2, 32 ]
-1
[ 64, 1, 64, 32, 16, 2, 64, 32, 4, 1, 64, 32, 8, 4, 2, 32 ]
-1
[ 64, 1, 64, 32, 16, 2, 64, 32, 4, 1, 64, 32, 8, 4, 2, 32 ]
0
[ 64, 1, 64, 32, 16, 2, 64, 32, 4, 1, 64, 32, 8, 4, 2, 32, 4 ]
0
[ 64, 1, 64, 32, 16, 2, 64, 32, 4, 1, 64, 32, 8, 4, 2, 32, 4, 2 ]
0
[ 64, 1, 64, 32, 16, 2, 64, 32, 4, 1, 64, 32, 8, 4, 2, 32, 4, 2, 1 ]
[ '1', '1', '1', '0', '1', '0', '0' ]
0
[ 64, 1, 64, 32, 16, 2, 64, 32, 4, 1, 64, 32, 8, 4, 2, 32, 4, 2, 1, 64 ]
0
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
/////////////////////////////////BRUTE SOLUTION OUTPUT:
Are
A
r
e
n
'
t
 
b
o
n
f
i
r
e
s
 
f
u
n
!
?
///////////////////////////////////////////////
\\\\\\\\\\\\\\\\\\\\\\FINAL BRUTE SOLUTION OUTPUT:
Aren't bonfires fun!?
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

//Everything Be True
//Check if the predicate (second argument) is "truthy" on all elements of a collection (first argument).

//In other words, you are given an array collection of objects. 
//The predicate 'pre' will be an object property and you need to return 'true' if its value is 'truthy'. 
//Otherwise, return 'false'.

//In JavaScript, 'truthy' values are values that translate to 'true' when evaluated in a Boolean context.

//Remember, you can access object properties through either dot notation or '[]' notation.


//UNCHANGED CODE:

//    function truthCheck(collection, pre) {
//      return pre;
//    }

//    truthCheck([{name: "Quincy", role: "Founder", isBot: false}, {name: "Naomi", role: "", isBot: false}, {name: "Camperbot", role: "Bot", isBot: true}], "isBot");

//CHANGED CODE:
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\first analysis
function truthCheck(collection, pre) {
  console.log(pre);
  console.log(Object.values(collection).pre);
  console.log(Object.keys(collection).length);
  console.log(Boolean(Object.values(collection).pre) === true);
  for (let i = 0; i < Object.keys(collection).length; i++) {
    console.log(Object.values(collection).name);
    console.log(Boolean(Object.values(collection)[i].pre) === true);
  }
  return pre;
}

let result = truthCheck([{name: "Quincy", role: "Founder", isBot: false}, {name: "Naomi", role: "", isBot: false}, {name: "Camperbot", role: "Bot", isBot: true}], "name");
console.log(result);
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
/////////////////////////////////////THE SOLUTION CODE:
function truthCheck(collection, pre) {
  let preClone = pre.slice();
  console.log(Object.values(preClone).join(''))
  console.log(collection[1][pre])
  for (let i = 0; i < collection.length; i++) {
        if (Boolean(collection[i][pre]) === false) {
          return false;
        };
  };return true;
  
}

let result = truthCheck([{name: "Quincy", role: "Founder", isBot: false}, {name: "Naomi", role: "", isBot: false}, {name: "Camperbot", role: "Bot", isBot: true}], "isBot");
console.log(result);
////////////////////////////////////////////////////////

//OUTPUT:
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\first analysis output
not very useful results
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
//////////////////////////////////////SOLUTION OUTPUT:
false
///////////////////////////////////////////////////////////

//Arguments Optional
//Create a function that sums two arguments together. 
//If only one argument is provided, then return a function that expects one argument and returns the sum.

//For example, 'addTogether(2, 3)' should return '5', and 'addTogether(2)' should return a function.

//Calling this returned function with a single argument will then return the sum:

//    var sumTwoAnd = addTogether(2);
//'sumTwoAnd(3)' returns '5'.

//If either argument isn't a valid number, return undefined.


//UNCHANGED CODE:

//    function addTogether() {
//      return false;
//    }

//    addTogether(2,3);

//CHANGED CODE:



//OUTPUT:


//


//UNCHANGED CODE:



//CHANGED CODE:



//OUTPUT:


//


//UNCHANGED CODE:



//CHANGED CODE:



//OUTPUT:


//


//UNCHANGED CODE:



//CHANGED CODE:



//OUTPUT:


//


//UNCHANGED CODE:



//CHANGED CODE:



//OUTPUT:


